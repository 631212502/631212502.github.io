<!DOCTYPE html>
<html lang="zh-CN">
<head>
    
    <meta name="baidu-site-verification" content="code-NrUjkxdqT5" />
    <title>No Game No Coding - Eutupia by 夏夢</title>
    <meta charset="UTF-8">
    <meta name="description" content="願いが叶う場所">
    <meta name="keywords" content="null">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    
    

    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/631212502/CDN/sucai/self-imagine/logo.png" type="image/png" />
    <meta name="description" content="Coding Learning from 代码随想录&#x2F;labuladong算法小抄">
<meta property="og:type" content="article">
<meta property="og:title" content="No Game No Coding">
<meta property="og:url" content="https://631212502.github.io/2021/12/12/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/index.html">
<meta property="og:site_name" content="Eutupia by 夏夢">
<meta property="og:description" content="Coding Learning from 代码随想录&#x2F;labuladong算法小抄">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020121623550681.png">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gntrds6r59g30du09mnpd.gif">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B92.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210104235346563.png">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/gifs/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.gif">
<meta property="og:image" content="https://bkimg.cdn.bcebos.com/pic/71cf3bc79f3df8dc1e9d5e85c211728b47102806?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U5Mg==,g_7,xp_5,yp_5/format,f_auto,">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gnad5itmk8g30iw0cqe83.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210204151702443.png">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008eGmZEly1gnbjjq8h16g30e20cwnpd.gif">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210219192050666.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201123195242899.png">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%80%BB%E7%BB%93%E5%A4%A7%E7%BA%B21.jpg">
<meta property="article:published_time" content="2021-12-12T10:47:55.000Z">
<meta property="article:modified_time" content="2023-12-02T09:04:09.890Z">
<meta property="article:author" content="Natu Matu">
<meta property="article:tag" content="Coding">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/2020121623550681.png">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/highlight.js@9.15.8/styles/atom-one-dark.css,npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css,gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css,npm/hexo-theme-nexmoe@latest/source/lib/mdui_043tiny/css/mdui.css,npm/hexo-theme-nexmoe@latest/source/lib/iconfont/iconfont.css?v=233" crossorigin>
    <!-- require APlayer -->
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
	<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
	<!-- require MetingJS : 未解决歌单播放问题-->
	<script src="https://cdn.jsdelivr.net/npm/meting@latest/dist/Meting.min.js"></script>
    <!-- require pjax -->
    <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
    <script src="https://cdn.bootcss.com/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>
    <!-- DPlayer -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/dplayer/dist/DPlayer.min.css">
    <script src="https://cdn.jsdelivr.net/npm/dplayer/dist/DPlayer.min.js"></script>
    <link rel="stylesheet" href="/css/style.css?v=1705851347246">
     
    
        <link rel="stylesheet" href="//at.alicdn.com/t/font_1038733_0xvrvpg9c0r.css">
    
    <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1705851347246">
    
        <link rel="stylesheet" href="/custom.css">
    
<meta name="generator" content="Hexo 5.4.0"></head>
<body class="mdui-drawer-body-left">
    
    <div id="pageContent">
        <div id="nexmoe-background">
            <div class="nexmoe-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/631212502/CDN/sucai/self-imagine/202211081936671.jpg)"></div>
            <div class="mdui-appbar mdui-shadow-0">
                <div class="mdui-toolbar">
                    <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
                    <div class="mdui-toolbar-spacer"></div>
                    <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
                    <a href="/" title="Natu Matu" class="mdui-btn mdui-btn-icon"><img src="https://cdn.jsdelivr.net/gh/631212502/CDN/sucai/self-imagine/avatar.jpg" alt="Natu Matu"></a>
                </div>
            </div>
        </div>
        <div id="nexmoe-header">
            <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="Natu Matu">
            <img src="https://cdn.jsdelivr.net/gh/631212502/CDN/sucai/self-imagine/avatar.jpg" alt="Natu Matu" alt="Natu Matu">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>51</div>
        <div><span>标签</span>17</div>
        <div><span>分类</span>4</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/archive.html" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/gate.html" title="小憩歌单">
            <i class="mdui-list-item-icon nexmoefont icon-coffee"></i>
            <div class="mdui-list-item-content">
                小憩歌单
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/about.html" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/PY.html" title="左邻右舍">
            <i class="mdui-list-item-icon nexmoefont icon-wechat-fill"></i>
            <div class="mdui-list-item-content">
                左邻右舍
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/album.html" title="时间光影">
            <i class="mdui-list-item-icon nexmoefont icon-calendar-fill"></i>
            <div class="mdui-list-item-content">
                时间光影
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/natunoyume.html" title="拾音纪行">
            <i class="mdui-list-item-icon nexmoefont icon-telegram"></i>
            <div class="mdui-list-item-content">
                拾音纪行
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
         
            <form id="search_form" action_e="https://cn.bing.com/search?q=" onsubmit="return search();">
                <label><input id="search_value" name="q" type="search" placeholder="搜索"></label>
            </form>
         
    </div>
</div>
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://qm.qq.com/cgi-bin/qm/qr?k=QriGs7GcXMPd6scnWXeO-IJ5TP8Qm8sd&noverify=0" target="_blank" mdui-tooltip="{content: 'QQ'}" style="color: rgb(249, 174, 8);background-color: rgba(249, 174, 8, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="https://space.bilibili.com/10580381" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .1);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/631212502" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .1);">
            <i class="nexmoefont icon-github"></i>
        </a><a class="mdui-ripple" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=631212502@qq.com" target="_blank" mdui-tooltip="{content: '邮箱'}" style="color: rgb(51, 153, 255);background-color: rgba(51, 153, 255, .1);">
            <i class="nexmoefont icon-mail-fill"></i>
        </a><a class="mdui-ripple" href="https://steamcommunity.com/profiles/76561199013116495/" target="_blank" mdui-tooltip="{content: 'steam'}" style="color: rgb(3, 98, 255);background-color: rgba(3, 98, 255, .1);">
            <i class="nexmoefont icon-steam"></i>
        </a><a class="mdui-ripple" href="https://www.xiaohongshu.com/user/profile/5fcc10c4000000000100b0b7?xhsshare=CopyLink&appuid=5fcc10c4000000000100b0b7&apptime=1660447872" target="_blank" mdui-tooltip="{content: '小红书'}" style="color: rgb(250, 136, 111);background-color: rgba(250, 136, 111, .1);">
            <i class="nexmoefont icon-calendar-fill"></i>
        </a><a class="mdui-ripple" href="/null" target="_blank" mdui-tooltip="{content: '知乎'}" style="color: ;background-color: ;">
            <i class="nexmoefont icon-zhihu"></i>
        </a><a class="mdui-ripple" href="/null" target="_blank" mdui-tooltip="{content: '推特'}" style="color: ;background-color: ;">
            <i class="nexmoefont icon-twitter"></i>
        </a><a class="mdui-ripple" href="https://chat.openai.com/chat" target="_blank" mdui-tooltip="{content: 'GPT'}" style="color: rgb(45, 13, 73);background-color: rgba(45, 13, 73, .1);">
            <i class="nexmoefont icon-eye-fill"></i>
        </a>
    </div>
</div>
    
    
  <div class="nexmoe-widget-wrap">
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/tags/Coding/" style="font-size: 17.14px;">Coding</a> <a href="/tags/Competition/" style="font-size: 11.43px;">Competition</a> <a href="/tags/MMDL/" style="font-size: 10px;">MMDL</a> <a href="/tags/S-Project/" style="font-size: 14.29px;">S_Project</a> <a href="/tags/mmdl/" style="font-size: 18.57px;">mmdl</a> <a href="/tags/page-building/" style="font-size: 12.86px;">page_building</a> <a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 15.71px;">博客</a> <a href="/tags/%E5%AD%A6%E6%9C%AF/" style="font-size: 15.71px;">学术</a> <a href="/tags/%E6%91%84%E5%BD%B1/" style="font-size: 14.29px;">摄影</a> <a href="/tags/%E6%97%85%E8%A1%8C/" style="font-size: 11.43px;">旅行</a> <a href="/tags/%E6%AD%8C%E3%81%86/" style="font-size: 11.43px;">歌う</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 17.14px;">笔记</a> <a href="/tags/%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">编程</a> <a href="/tags/%E8%A8%80%E8%91%89/" style="font-size: 20px;">言葉</a> <a href="/tags/%E8%AE%B0%E5%BD%95/" style="font-size: 14.29px;">记录</a> <a href="/tags/%E8%AE%BA%E6%96%87/" style="font-size: 12.86px;">论文</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 18.57px;">随笔</a>
    </div>
    
  </div>

    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章分类</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/小さな考え/">小さな考え</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/无情の勉強マシン/">无情の勉強マシン</a>
          <span class="category-list-count">7</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/言けない言葉/">言けない言葉</a>
          <span class="category-list-count">6</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/音楽が辞めよう/">音楽が辞めよう</a>
          <span class="category-list-count">3</span>
        </li>

        
      </ul>

    </div>
  </div>


    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/">2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/">2023</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a><span class="archive-list-count">16</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/">2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/">2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/">2011</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/">2010</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>



    
    <span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt = new Date("08/31/2021 17:38:00"); //在此处修改你的建站时间
        now.setTime(now.getTime() + 250);
        days = (now - grt) / 1000 / 60 / 60 / 24;
        dnum = Math.floor(days);
        hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
        hnum = Math.floor(hours);
        if (String(hnum).length == 1) {
            hnum = "0" + hnum;
        }
        minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
        mnum = Math.floor(minutes);
        if (String(mnum).length == 1) {
            mnum = "0" + mnum;
        }
        seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
        snum = Math.round(seconds);
        if (String(snum).length == 1) {
            snum = "0" + snum;
        }
        document.getElementById("timeDate").innerHTML = 
            " 风雨中度过了 " + dnum + " 天 ";
        document.getElementById("times").innerHTML =
            hnum + " 小时 " + mnum + " 分 "; 
    }
    setInterval("createtime()", 250);
</script>
<!-- + snum + " 秒 "-->
    
</aside>


    <div class="nexmoe-copyright">
        &copy; 2024 Natu Matu
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        
    </div>
</div><!-- .nexmoe-drawer -->
<div style="font-size: 13px">
    <link rel="stylesheet" href="https://widget.heweather.net/standard/static/css/he-standard.css?v=1.4.0"><script src="https://widget.heweather.net/standard/static/js/he-standard.js?v=1.4.0"></script><script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    本站总访问量  <a id="busuanzi_value_site_pv"></a> 次<br>
    本站访客数<a id="busuanzi_value_site_uv"></a>人次
</div>

        </div>
        <div id="nexmoe-content">
            <div class="nexmoe-primary">
                <div class="nexmoe-post">

  <article>
      
          <div class="nexmoe-post-cover" style="padding-bottom: NaN%;"> 
              <img data-src="https://cdn.jsdelivr.net/gh/631212502/CDN/sucai/self-imagine/t01c67f3cb632e199e2.jpg" data-sizes="auto" alt="No Game No Coding" class="lazyload">
              <h1>No Game No Coding</h1>
          </div>
      
      
      <div class="nexmoe-post-meta nexmoe-rainbow" style="margin:10px 0!important;">
    <a><i class="nexmoefont icon-calendar-fill"></i>2021年12月12日</a>
    <a><i class="nexmoefont icon-areachart"></i>22.6k 字</a>
    <a><i class="nexmoefont icon-time-circle-fill"></i>大概 105 分钟</a>
</div>

      

      <p><strong>Coding Learning from 代码随想录/labuladong算法小抄</strong></p>
<span id="more"></span>
<h2 id="无游戏不编程"><a href="#无游戏不编程" class="headerlink" title="无游戏不编程"></a>无游戏不编程</h2><p>&emsp;&emsp; 在我看来，编程这回事和我玩的大型战略游戏（星际，魔兽）没有太大的区别。从某种角度上讲：变量就是我生产的最小战斗单位，类似于一个个执行生产任务的工兵；函数无非就是为他们提供冲锋思路（没有返回值，过程中带来一些战果）、打造的武器装备（例如numpy转tensor）或者回炉重铸打造出更合适的单位（带返回值），类就是我设计好的作战集群，里面有各式各样的职阶和武装。我可以以剑圣为蓝本生成一个无敌的类，初始化属性数值拉满，技能隐身跳砍、火舞旋风移速快的同时伤害还可以爆炸~</p>
<h2 id="Leetcode学习日历"><a href="#Leetcode学习日历" class="headerlink" title="Leetcode学习日历"></a>Leetcode学习日历</h2><p>安利这个<a target="_blank" rel="noopener" href="https://www.programmercarl.com/">神奇的网站</a><br><strong>逻辑完美，细节精巧，代码AC</strong><br>个人编程菜鸡速成打法步骤：</p>
<ol>
<li>大致阅览某一类型题的基础知识，知道这是个什么东西即可</li>
<li>开始跟着这一类型刷题，总结思路，<strong>尝试写出这种思路的清晰伪代码</strong></li>
<li>隔一段时间后（1~3天内为宜，因为对题的思路还有印象）重新看题回忆这部分伪代码，想不起来就找出之前的笔记，根据伪代码还原出AC的代码</li>
<li>归纳这一类体型和伪代码解题套路（<strong>为什么不是思路，因为只是有思路没有代码还原能力的锻炼在编程中是万万不可取的，是代码人的大忌，记伪代码的同时一般也会顺便记住代码还原的关键地方</strong>）</li>
<li>开始新循环或者刷新题稳固、拓展、归纳、梳理到自己的套路中来</li>
</ol>
<h3 id="数据结构基础"><a href="#数据结构基础" class="headerlink" title="数据结构基础"></a>数据结构基础</h3><h4 id="算法性能：时间复杂度与空间复杂度"><a href="#算法性能：时间复杂度与空间复杂度" class="headerlink" title="算法性能：时间复杂度与空间复杂度"></a>算法性能：时间复杂度与空间复杂度</h4><ul>
<li>时间复杂度是一个函数，它定性描述该算法的运行时间</li>
<li>空间复杂度是对一个算法在运行过程中占用内存空间大小的量度，记做$S(n)=O(f(n)$。空间复杂度(Space Complexity)记作S(n) 依然使用大O来表示。利用程序的空间复杂度，可以对程序运行中需要多少内存有个预先估计</li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><strong>概念：连续内存空间上相同数据的集合：内存是挨着的，数据类型是相同的</strong></p>
<ul>
<li><p>基本知识：</p>
<ol>
<li>数组可以通过下标寻址，删除或者插入元素要对整个数组进行连续位移操作</li>
<li>数组下标都是从0开始，而且在内存空间分配上是连续的<h4 id="二分查找问题"><a href="#二分查找问题" class="headerlink" title="二分查找问题"></a>二分查找问题</h4></li>
</ol>
</li>
<li><p>使用条件：在一个有序的数组里，直接用二分法判别相当于卡德一下就干掉了一半的数据，极为搞笑，类似于数学里的不断二分求函数在某一个区间上的极值点一样。<strong>PS:数组有序，并且无重复元素是前提，二分法不会写基本就是边界左右怎么选定没搞清楚，可以用闭区间，也可以用左闭又开等，具体考虑实际意义</strong></p>
<ul>
<li>经典的二分法寻值问题</li>
</ul>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span>(<span class="hljs-params">self, nums, target</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type target: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        left = <span class="hljs-number">0</span><br>        right = <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> left &lt;= right: <span class="hljs-comment">#此处规定区间左右界规则很重要，当二分到左右界会交叉时break，返回-1</span><br>            middel = (right + left) / <span class="hljs-number">2</span> <span class="hljs-comment">#这一步是我的代码</span><br>            <span class="hljs-comment">#middel = ((right - left) // 2) + left #官方代码</span><br>            <span class="hljs-keyword">if</span> nums[middel] == target:<br>                <span class="hljs-keyword">return</span> middel<br>            <span class="hljs-comment">#设想思路，此处num[middle]已经和target比较过了，所以下面再比较时可以将边界向左向右位移一位。</span><br>            <span class="hljs-keyword">if</span> nums[middel] &gt; target:<br>                right = middel - <span class="hljs-number">1</span> <span class="hljs-comment">#错因，没有搞清楚二分之后左右边界的选择问题，目标在左应该把右边界往中间偏左缩减一位</span><br>            <span class="hljs-keyword">else</span>:<br>                left = middel + <span class="hljs-number">1</span> <span class="hljs-comment">#目标在右应该把左边界在中位数上往右走一位，确定合适的区间</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<ul>
<li>寻值求插入问题<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">searchInsert</span>(<span class="hljs-params">self, nums, target</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :type nums: List[int]</span><br><span class="hljs-string">    :type target: int</span><br><span class="hljs-string">    :rtype: int</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>     <span class="hljs-comment">#二分法找个数，没有就返回索引</span><br>    left = <span class="hljs-number">0</span><br>    right = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> target &lt;= nums[left]:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> target &gt; nums[right]:<br>        <span class="hljs-keyword">return</span> right + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> left &lt;= right:<br>        <span class="hljs-built_in">print</span>(left)<br>        <span class="hljs-built_in">print</span>(right)<br>        mid = <span class="hljs-built_in">int</span>((left + right) / <span class="hljs-number">2</span>)<br>        <span class="hljs-built_in">print</span>(mid)<br>        <span class="hljs-keyword">if</span> nums[mid] &lt; target:<br>            <span class="hljs-comment">#目标在右边</span><br>            left = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> nums[mid] &gt; target:<br>            <span class="hljs-comment">#目标在左边</span><br>            right = mid - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> nums[mid] == target:<br>            <span class="hljs-keyword">return</span> mid <span class="hljs-comment">#寻找值情况，如果target在序列里，返回此时的mid</span><br>    <span class="hljs-comment"># 如果target不在序列里，有什么数学/逻辑关系可以判明他的索引</span><br>    <span class="hljs-keyword">if</span> target &lt; nums[mid]:<span class="hljs-comment">#看循环，当target不在序列里，循环最终会输出mid = left = right，所以判别target在mid的左右相对关系既可以找到其位置，当target小于num【mid】时，此时在mid处插入，</span><br>        <span class="hljs-keyword">return</span> mid<br>    <span class="hljs-keyword">else</span>: <span class="hljs-comment">#如果target大了，那就在后一位插入，所以索引加1</span><br>        <span class="hljs-keyword">return</span> mid + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li>
<li>OOOOXXXX类数组第一个错误X出现在哪的问题<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">firstBadVersion</span>(<span class="hljs-params">self, n</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :type n: int</span><br><span class="hljs-string">    :rtype: int</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment">#题意明说少调用，肯定排除了遍历，出了遍历还能找到查询的方法只有二分搜索了</span><br>    <span class="hljs-comment">#可以转化为在[oooooXXXXXX]中查找第一个X，O,X类似于大小比较</span><br>    left = <span class="hljs-number">0</span><br>    right = n<br>    <span class="hljs-built_in">print</span>(isBadVersion(<span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">while</span> left &lt; right:<br>        mid = <span class="hljs-built_in">int</span>((left + right) / <span class="hljs-number">2</span>) <span class="hljs-comment">#特殊个例，单圈或者单叉的情况下怎么让循环也能判断出来，把左边虚拟成0版本，反正是X的话马上就会+1跳出循环，此时right是1，题意bad大于1很关键，如果bad可以等于0，但我的right任然会取到1，所以要另外加上无错误返回false的判别</span><br>        <span class="hljs-built_in">print</span>(mid)<br>        <span class="hljs-keyword">if</span> isBadVersion(mid):<br>            <span class="hljs-comment">#检测到错误版本</span><br>            right = mid          <span class="hljs-comment">#为什么这么写，因为题意要求的是第一个叉何时出现，所以最终值一定是取在right上的，判定时机就是当right取到target时，left会不断+1直到等于right，此时return</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isBadVersion(mid):<br>            <span class="hljs-comment">#检测到非错误版本</span><br>            left = mid  + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> right<br></code></pre></td></tr></table></figure>
<h4 id="元素移除问题"><a href="#元素移除问题" class="headerlink" title="元素移除问题"></a>元素移除问题</h4>问题：给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</li>
</ul>
</li>
<li><p>方法：</p>
<ul>
<li>双for循环：一个for遍历数组，一个for更新数组：一个for找到重复数，另一个for调整删去重复树</li>
<li>双指针法：快慢指针快速的遍历查找，慢指针不断按快指针参数调整数组，在目标值的时候快指针直接++跳过去，然后将后一位连接给慢指针（当快指针遇到目标值时，慢指针会停下）所以当快指针继续操作时会把目标后面的值衔接到慢指针后，达到删去目标元素的功能。</li>
</ul>
</li>
<li><p>代码：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">removeElement</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        fast = slow = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> fast &lt; <span class="hljs-built_in">len</span>(nums):<br>            <span class="hljs-keyword">if</span> nums[fast] != val:<br>                <span class="hljs-comment">#fast += 1</span><br>                nums[slow] = nums[fast]<br>                slow += <span class="hljs-number">1</span><br>            fast += <span class="hljs-number">1</span><br>                <br>        <span class="hljs-keyword">return</span> slow<br></code></pre></td></tr></table></figure>
<h4 id="有序数组的平方问题"><a href="#有序数组的平方问题" class="headerlink" title="有序数组的平方问题"></a>有序数组的平方问题</h4><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。排序此时最好不用内置函数sort<br>思路：</p>
</li>
</ul>
<ol>
<li>暴力排序：先计算后排序，时间复杂度大概是n+nlogn</li>
<li>双指针法：双指针的使用很巧妙的解决了计算和排序的问题，变计算边比较边排序，时间复杂度为n（只进行了一次从右到左的遍历排序）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; A)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> k = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(A.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt;= j;) &#123; <span class="hljs-comment">// 注意这里要i &lt;= j，因为最后要处理两个元素</span><br>            <span class="hljs-keyword">if</span> (A[i] * A[i] &lt; A[j] * A[j])  &#123;<br>                result[k--] = A[j] * A[j];<br>                j--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                result[k--] = A[i] * A[i];<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
pyothon解法：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sortedSquares</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:</span><br>        l = <span class="hljs-built_in">len</span>(nums)<br>        i,j,k = <span class="hljs-number">0</span>, l - <span class="hljs-number">1</span>, l - <span class="hljs-number">1</span><br>        ans = [-<span class="hljs-number">1</span>] * l<br>        <span class="hljs-built_in">print</span>(ans)<br>        <span class="hljs-keyword">while</span> i &lt;= j:<br>            lm = nums[i] ** <span class="hljs-number">2</span><br>            rm = nums[j] ** <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> lm &gt;= rm:<br>                ans[k] = lm  <br>                k -= <span class="hljs-number">1</span><br>                i += <span class="hljs-number">1</span>       <br>            <span class="hljs-keyword">else</span>:<br>                ans[k] = rm<br>                k -= <span class="hljs-number">1</span><br>                j -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure>
<h4 id="长度最小的子数组问题"><a href="#长度最小的子数组问题" class="headerlink" title="长度最小的子数组问题"></a>长度最小的子数组问题</h4>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回0。<br>滑动窗口法<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span> <span class="hljs-comment">#此代码逻辑是通的，只不过逐个滑动放缩窗口效率比较低，应该采取双滑动</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minSubArrayLen</span>(<span class="hljs-params">self, target: <span class="hljs-built_in">int</span>, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        l = <span class="hljs-built_in">len</span>(nums)<br>        i, j, k = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        t_lmin = <span class="hljs-number">0</span><br>        lmin = l<br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt;= l - <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">while</span> j &lt;= l - <span class="hljs-number">1</span>: <br>                count = count + nums[j]<br>                <span class="hljs-built_in">print</span>(count)<br>                <span class="hljs-keyword">if</span> count &gt;= target: <span class="hljs-comment">#满足大于的条件了，看是否是最短序列</span><br>                    t_lmim = j - i + <span class="hljs-number">1</span> <br>                    <span class="hljs-comment">#这一步之后其实可以用上conut -=nums[i]让左指针也跟着动</span><br>                    <span class="hljs-keyword">if</span> t_lmim &lt;= lmin: <span class="hljs-comment">#满足目前是最小序列条件，更新</span><br>                        k = <span class="hljs-number">1</span><br>                        lmin = t_lmim<br>                        <span class="hljs-keyword">break</span><br>                    <span class="hljs-keyword">else</span>: <span class="hljs-comment">#这个i下不满足最小序列，爬</span><br>                        <span class="hljs-keyword">break</span><br>                <span class="hljs-comment">#不满足大于条件，右指针要开始向右移动扩大数组求值范围</span><br>                <span class="hljs-keyword">else</span>:<br>                    j += <span class="hljs-number">1</span><br>            i += <span class="hljs-number">1</span> <br>            j = i<br>            count = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">if</span> lmin == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> lmin<br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> lmin<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span> <span class="hljs-comment">#最佳，此方法与我的方法相比更为简洁，我是逐个移动左指针然后求右，时间复杂度为（n+nlogn）这个方法是双移动指针，一直用某一个区间去适配，小了改大，大了改小，一直移动遍历完数组就可以了，不用重复多次循环计算输出。</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minSubArrayLen</span>(<span class="hljs-params">self, target: <span class="hljs-built_in">int</span>, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        l = <span class="hljs-built_in">len</span>(nums)<br>        i, j = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        lmin = <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>)<br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(l):<br>            count += nums[i]<br>            <span class="hljs-keyword">while</span> count &gt;= target:<br>                lmin = <span class="hljs-built_in">min</span>(lmin, i-j+<span class="hljs-number">1</span>)<br>                count -= nums[j] <span class="hljs-comment"># 左指针右移，值区间缩减</span><br>                j += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> lmin == <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> lmin<br></code></pre></td></tr></table></figure>
<h4 id="螺旋矩阵问题"><a href="#螺旋矩阵问题" class="headerlink" title="螺旋矩阵问题"></a>螺旋矩阵问题</h4>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。<br><strong>*:在这一道题要开始深入理解循环不变量原则，就是在循环使用的时候，要清楚什么变量是可以动的，什么是不可以动的，区间的大小，开闭情况都要考虑一下，不然就容易写出各种bug的死循环。</strong></li>
</ol>
<p><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/2020121623550681.png" alt="实例" class="lazyload"></p>
<ol>
<li><p>代码要逻辑自洽，过度依赖临时逻辑修修补补往往都是拆了东墙补西墙自讨苦吃</p>
<ul>
<li>比如本题，既然是寻找螺旋数字特征，就应该依据螺旋走向的逻辑逐步往里一层一层循环遍历赋值<br>而不是纯纯列出矩阵后边遍历边运算边赋值。下图可以看出，边界条件很多，如果不控制好逐层全覆盖的逻辑表达，则很难写出准确的代码。</li>
</ul>
</li>
<li><p>逻辑矩阵也有许多<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/spiral-matrix/submissions/">变体</a>,比如有一些不规则的矩阵，有可能是遍历，有可能也是填充，但本质都离不开确定好四条边后进行操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generateMatrix</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:</span><br>        <span class="hljs-comment">#定义一个大小为n*n的二维数组</span><br>        res = [[<span class="hljs-number">0</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-comment">#print(res)</span><br>        loop = n / <span class="hljs-number">2</span><br>        x, y = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        mid = <span class="hljs-built_in">int</span>(n /<span class="hljs-number">2</span>)<br>        count = <span class="hljs-number">0</span><br>        offset = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> loop &gt;<span class="hljs-number">0</span>:<br>            i = x<br>            j = y<br>            <span class="hljs-keyword">while</span> j &lt; y + n - offset:<br>                count += <span class="hljs-number">1</span><br>                res[x][j] = count <br>                j += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> i &lt; x + n - offset:<br>                count +=<span class="hljs-number">1</span><br>                res[i][j] = count<br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> j &gt; y:<br>                count += <span class="hljs-number">1</span><br>                res[i][j] = count<br>                j -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> i &gt; x:<br>                count += <span class="hljs-number">1</span><br>                res[i][j] = count<br>                i -= <span class="hljs-number">1</span><br>            <br>            x += <span class="hljs-number">1</span><br>            y += <span class="hljs-number">1</span><br>            offset += <span class="hljs-number">2</span><br>            loop -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span>:<br>            count += <span class="hljs-number">1</span><br>            res[mid][mid] = count<br>            <span class="hljs-built_in">print</span>(res)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h4 id="轮转数组-旋转链表-翻转字符串里的单词"><a href="#轮转数组-旋转链表-翻转字符串里的单词" class="headerlink" title="轮转数组/旋转链表/翻转字符串里的单词"></a>轮转数组/旋转链表/翻转字符串里的单词</h4><p>给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。<br>示例：</p>
<p> 输入: nums = [1,2,3,4,5,6,7], k = 3<br> 输出: [5,6,7,1,2,3,4]<br> 解释:<br> 向右轮转 1 步: [7,1,2,3,4,5,6]<br> 向右轮转 2 步: [6,7,1,2,3,4,5]<br> 向右轮转 3 步: [5,6,7,1,2,3,4]</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rotate</span>(<span class="hljs-params">self, nums, k</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: None Do not return anything, modify nums in-place instead.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment">#这个题的难点是怎么让代码做出论转的动作，一般的思路是当左右指针走到尽头了重新进行循环，试试看吧</span><br>        <br>        <span class="hljs-comment">#定义一个轮转操作函数，变量是操作步长k，还有操作序列nums</span><br>        right = <span class="hljs-built_in">len</span>(nums) - (k % <span class="hljs-built_in">len</span>(nums)) <span class="hljs-comment">#求步长的余数，如果刚好是数组的长度，则可以等于没走</span><br>        res = []<br>        <span class="hljs-comment">#换个思路，再找一个数组，当right走了k步后，从零开始跟着right捡数据，right就负责反复遍历数组</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-comment">#print(right)</span><br>            <span class="hljs-keyword">if</span> right == <span class="hljs-built_in">len</span>(nums):<br>                right = <span class="hljs-number">0</span><br>            res.append(nums[right])<br>            right += <span class="hljs-number">1</span><br>            <span class="hljs-built_in">print</span>(res)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            nums[i] = res[i]<br></code></pre></td></tr></table></figure>

<p>翻转字符串单词问题(一次AC)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseWords</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment">#转换数列、遍历、切词、单个单词翻转函数、遍历完毕</span><br>        res = []<br>        s = <span class="hljs-built_in">list</span>(s)<br>        left = <span class="hljs-number">0</span><br>        right = <span class="hljs-number">0</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exchange</span>(<span class="hljs-params">l,r,s</span>):</span><br>            <span class="hljs-keyword">while</span> l &lt; r:<br>                    s[l], s[r-<span class="hljs-number">1</span>] = s[r-<span class="hljs-number">1</span>], s[l] <br>                    l += <span class="hljs-number">1</span><br>                    r -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> right != <span class="hljs-built_in">len</span>(s):<br>            right += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span>  right == <span class="hljs-built_in">len</span>(s) <span class="hljs-keyword">or</span> s[right] == <span class="hljs-string">&quot; &quot;</span>:<br>                <span class="hljs-comment">#循环函数</span><br>                exchange(left,right,s)<br>                left = right + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.join(s)<br><br></code></pre></td></tr></table></figure>
<h4 id="数组-列表-排序问题-手撕排序"><a href="#数组-列表-排序问题-手撕排序" class="headerlink" title="数组[列表]排序问题:手撕排序"></a>数组[列表]排序问题:手撕排序</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-an-array/">leetcode排序</a><br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-an-array/solution/pai-xu-shu-zu-by-leetcode-solution/">解答</a></p>
<ol>
<li>快速排序<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sortArray</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        left = <span class="hljs-number">0</span><br>        right = <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span><br>        nums = self.quicksort(left,right,nums)<br>        <span class="hljs-keyword">return</span> nums<br>        <span class="hljs-comment">#排序数组，手撕快排</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quicksort</span>(<span class="hljs-params">self,left,right,a</span>):</span><br>        <span class="hljs-keyword">if</span> left &gt; right:<br>            <span class="hljs-keyword">return</span><br>        temp = a[left] <span class="hljs-comment">#记下此时的基准数</span><br>        <span class="hljs-comment">#更新左右哨兵标注i，j</span><br>        i = left<br>        j = right<br>        <span class="hljs-comment">#print(j)</span><br>        <span class="hljs-keyword">while</span> i != j:<br>            <span class="hljs-comment">#哨兵移动,找逆差对，记得先右再左（很重要）</span><br>            <span class="hljs-keyword">while</span> a[j] &gt;= temp <span class="hljs-keyword">and</span> i &lt; j: <span class="hljs-comment">#先从右往左找</span><br>                j -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> a[i] &lt;= temp <span class="hljs-keyword">and</span> i &lt; j: <span class="hljs-comment">#从左往右找</span><br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> i &lt; j: <span class="hljs-comment">#如果没有碰头，交换数的位置</span><br>                t = a[j]<br>                a[j] = a[i]<br>                a[i] = t<br>        <span class="hljs-comment">#i找到了中间，交换参考点</span><br>        a[left] = a[i] <span class="hljs-comment">#重点放左边</span><br>        a[i] = temp <span class="hljs-comment">#参考点给到中间</span><br>        <span class="hljs-comment">#两边递归求解</span><br>        self.quicksort(left,i-<span class="hljs-number">1</span>,a)<br>        self.quicksort(i+<span class="hljs-number">1</span>,right,a) <br>        <span class="hljs-keyword">return</span> a<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sortArray</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">partition</span>(<span class="hljs-params">arr, low, high</span>):</span><br>            pivot_idx = random.randint(low, high)                   <span class="hljs-comment"># 随机选择pivot</span><br>            arr[low], arr[pivot_idx] = arr[pivot_idx], arr[low]     <span class="hljs-comment"># pivot放置到最左边</span><br>            pivot = arr[low]                                        <span class="hljs-comment"># 选取最左边为pivot</span><br>            left, right = low, high     <span class="hljs-comment"># 双指针</span><br>            <span class="hljs-keyword">while</span> left &lt; right:<br>                <span class="hljs-keyword">while</span> left&lt;right <span class="hljs-keyword">and</span> arr[right] &gt;= pivot:          <span class="hljs-comment"># 找到右边第一个&lt;pivot的元素</span><br>                    right -= <span class="hljs-number">1</span><br>                arr[left] = arr[right]                             <span class="hljs-comment"># 并将其移动到left处           </span><br>                <span class="hljs-keyword">while</span> left&lt;right <span class="hljs-keyword">and</span> arr[left] &lt;= pivot:           <span class="hljs-comment"># 找到左边第一个&gt;pivot的元素</span><br>                    left += <span class="hljs-number">1</span><br>                arr[right] = arr[left]                             <span class="hljs-comment"># 并将其移动到right处</span><br>            arr[left] = pivot           <span class="hljs-comment"># pivot放置到中间left=right处</span><br>            <span class="hljs-keyword">return</span> left<br>        <br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">arr, low, high</span>):</span><br>            <span class="hljs-keyword">if</span> low &gt;= high:             <span class="hljs-comment"># 递归结束</span><br>                <span class="hljs-keyword">return</span>  <br>            mid = partition(arr, low, high)     <span class="hljs-comment"># 以mid为分割点，右边元素&gt;左边元素</span><br>            quickSort(arr, low, mid-<span class="hljs-number">1</span>)          <span class="hljs-comment"># 递归对mid两侧元素进行排序</span><br>            quickSort(arr, mid+<span class="hljs-number">1</span>, high)<br>        quickSort(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>)         <span class="hljs-comment"># 调用快排函数对nums进行排序</span><br>        <span class="hljs-keyword">return</span> nums<br></code></pre></td></tr></table></figure></li>
<li>堆排序<br>堆排序的思想就是先将待排序的序列建成大根堆，使得每个父节点的元素大于等于它的子节点。此时整个序列最大值即为堆顶元素，我们将其与末尾元素交换，使末尾元素为最大值，然后再调整堆顶元素使得剩下的 n-1 个元素仍为大根堆，再重复执行以上操作我们即能得到一个有序的序列。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max_heapify</span>(<span class="hljs-params">self, heap, root, heap_len</span>):</span><br>        p = root<br>        <span class="hljs-keyword">while</span> p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt; heap_len:<br>            l, r = p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, p * <span class="hljs-number">2</span> + <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> heap_len &lt;= r <span class="hljs-keyword">or</span> heap[r] &lt; heap[l]:<br>                nex = l<br>            <span class="hljs-keyword">else</span>:<br>                nex = r<br>            <span class="hljs-keyword">if</span> heap[p] &lt; heap[nex]:<br>                heap[p], heap[nex] = heap[nex], heap[p]<br>                p = nex<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_heap</span>(<span class="hljs-params">self, heap</span>):</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(heap) - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            self.max_heapify(heap, i, <span class="hljs-built_in">len</span>(heap))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">heap_sort</span>(<span class="hljs-params">self, nums</span>):</span><br>        self.build_heap(nums)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            nums[i], nums[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>], nums[i]<br>            self.max_heapify(nums, <span class="hljs-number">0</span>, i)<br>            <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sortArray</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:</span><br>        self.heap_sort(nums)<br>        <span class="hljs-keyword">return</span> nums<br></code></pre></td></tr></table></figure></li>
<li>并归排序<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_sort</span>(<span class="hljs-params">self, nums, l, r</span>):</span><br>        <span class="hljs-keyword">if</span> l == r:<br>            <span class="hljs-keyword">return</span><br>        mid = (l + r) // <span class="hljs-number">2</span><br>        self.merge_sort(nums, l, mid)<br>        self.merge_sort(nums, mid + <span class="hljs-number">1</span>, r)<br>        tmp = []<br>        i, j = l, mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> i &lt;= mid <span class="hljs-keyword">or</span> j &lt;= r:<br>            <span class="hljs-keyword">if</span> i &gt; mid <span class="hljs-keyword">or</span> (j &lt;= r <span class="hljs-keyword">and</span> nums[j] &lt; nums[i]):<br>                tmp.append(nums[j])<br>                j += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                tmp.append(nums[i])<br>                i += <span class="hljs-number">1</span><br>        nums[l: r + <span class="hljs-number">1</span>] = tmp<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sortArray</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:</span><br>        self.merge_sort(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> nums<br></code></pre></td></tr></table></figure>
<h4 id="数组部分总结"><a href="#数组部分总结" class="headerlink" title="数组部分总结"></a>数组部分总结</h4>数组是存放在 <strong>连续内存空间</strong> 上 <strong>相同类型数据</strong> 的集合</li>
</ol>
<ul>
<li>一些典型数组处理方法：<ul>
<li>二分法：二分的难点在于升序/降序（下面以升序为例子）奇偶长度数组的边界处理，边界比较后如何选择新边界十分关键（是左1还是右1，大体逻辑就是，边界值大于目标值，则目标在左边，右边界移动到这，因为此处已经进行过计算，则可再向左移动一位，右边同理）</li>
<li>双指针法：针对双循环的题目，可以用一快一慢的指针减少时间复杂度(n^2→n)，比如对数组进行删除操作<br><img data-fancybox="gallery" data-sizes="auto" data-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntrds6r59g30du09mnpd.gif" alt="双指针" class="lazyload"></li>
<li>滑动窗口法：滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。<br><img data-fancybox="gallery" data-sizes="auto" data-src="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif" alt="滑窗" class="lazyload"></li>
<li>螺旋矩阵——模拟行为法：<br>相信大家又遇到过这种情况： 感觉题目的边界调节超多，一波接着一波的判断，找边界，踩了东墙补西墙，好不容易运行通过了，代码写的十分冗余，毫无章法，其实真正解决题目的代码都是简洁的，或者有原则性的。</li>
</ul>
</li>
</ul>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="什么是链表？"><a href="#什么是链表？" class="headerlink" title="什么是链表？"></a>什么是链表？</h4><p>链表为一种通过指针串联在一起的线性结构，每一个节点有两部分组成，头和指针/数据域和指针域<br>最后一个节点的指针域指向null（其为空指针），相对应的，入口节点为头指针。<br>链表有单双链表和循环链表，在内存中独立散乱分布（和数组相区别）</p>
<h4 id="移除节点"><a href="#移除节点" class="headerlink" title="移除节点"></a>移除节点</h4><p>为了操作统一，可以虚拟一个头结点进行操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">// 删除头结点</span><br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">NULL</span> &amp;&amp; head-&gt;val == val) &#123; <span class="hljs-comment">// 注意这里不是if</span><br>            ListNode* tmp = head;<br>            head = head-&gt;next;<br>            <span class="hljs-keyword">delete</span> tmp;<br>        &#125;<br><br>        <span class="hljs-comment">// 删除非头结点</span><br>        ListNode* cur = head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span> &amp;&amp; cur-&gt;next!= <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur-&gt;next-&gt;val == val) &#123;<br>                ListNode* tmp = cur-&gt;next;<br>                cur-&gt;next = cur-&gt;next-&gt;next;<br>                <span class="hljs-keyword">delete</span> tmp;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h4><p>设计链表就是编写一个具有功能函数的链表类，比如可以获取链表的某个值，插入删除某个节点，追加节点等等，示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, val</span>):</span><br>        self.val = val<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLinkedList</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self._head = Node(<span class="hljs-number">0</span>)<br>        self._count = <span class="hljs-number">0</span><br><br><span class="hljs-comment">#获取第n个节点的值并返回</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= index &lt; self._count:<br>            node = self._head<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> rang(index + <span class="hljs-number">1</span>):<br>                node = node.<span class="hljs-built_in">next</span><span class="hljs-comment">#node指针遍历到目标节点</span><br>            <span class="hljs-keyword">return</span> node.val<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addAtHead</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        self.addAtIndex(<span class="hljs-number">0</span>, val)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addAtTail</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        self.addAtIndex(self._count, val)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addAtIndex</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span>, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span>: <span class="hljs-comment">#小于目标节点</span><br>            index = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">elif</span> index &gt; self._count:<span class="hljs-comment">#目标节点大于列表，爆了</span><br>            <span class="hljs-keyword">return</span><br>        <br>        self._count +=<span class="hljs-number">1</span> <span class="hljs-comment">#一个指针要先去到下一节点</span><br><br>        add_node = Node(val)<br>        prev_node, current_node = <span class="hljs-literal">None</span>, self._head <span class="hljs-comment">#初始化</span><br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(index + <span class="hljs-number">1</span>):<span class="hljs-comment">#移动</span><br>            prev_node, current_node = current_node, current_node.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">else</span>:<span class="hljs-comment">#遇到</span><br>            prev_node.<span class="hljs-built_in">next</span>, add_node.<span class="hljs-built_in">next</span> = add_node, current_node<span class="hljs-comment">#连接</span><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deleteAtIndex</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= index &lt; self._count:<br>            self._count -= <span class="hljs-number">1</span><br>            prev_node, current_node = Node, self._head<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(index + <span class="hljs-number">1</span>):<br>                prev_node, current_node = current_node, current_node.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                prev_node, current_node = current_node.<span class="hljs-built_in">next</span>, <span class="hljs-literal">None</span><br><br><span class="hljs-comment"># 双链表</span><br><span class="hljs-comment"># 相对于单链表, Node新增了prev属性</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>:</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, val</span>):</span><br>        self.val = val<br>        self.prev = <span class="hljs-literal">None</span><br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLinkedList</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self._head, self._tail = Node(<span class="hljs-number">0</span>), Node(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 虚拟节点</span><br>        self._head.<span class="hljs-built_in">next</span>, self._tail.prev = self._tail, self._head<br>        self._count = <span class="hljs-number">0</span>  <span class="hljs-comment"># 添加的节点数</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_get_node</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span></span>) -&gt; Node:</span><br>        <span class="hljs-comment"># 当index小于_count//2时, 使用_head查找更快, 反之_tail更快</span><br>        <span class="hljs-keyword">if</span> index &gt;= self._count // <span class="hljs-number">2</span>:<br>            <span class="hljs-comment"># 使用prev往前找</span><br>            node = self._tail<br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self._count - index):<br>                node = node.prev<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 使用next往后找</span><br>            node = self._head   <br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(index + <span class="hljs-number">1</span>):<br>                node = node.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> node<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Get the value of the index-th node in the linked list. If the index is invalid, return -1.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= index &lt; self._count:<br>            node = self._get_node(index)<br>            <span class="hljs-keyword">return</span> node.val<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addAtHead</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self._update(self._head, self._head.<span class="hljs-built_in">next</span>, val)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addAtTail</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Append a node of value val to the last element of the linked list.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self._update(self._tail.prev, self._tail, val)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addAtIndex</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span>, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span>:<br>            index = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">elif</span> index &gt; self._count:<br>            <span class="hljs-keyword">return</span><br>        node = self._get_node(index)<br>        self._update(node.prev, node, val)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_update</span>(<span class="hljs-params">self, prev: Node, <span class="hljs-built_in">next</span>: Node, val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            更新节点</span><br><span class="hljs-string">            :param prev: 相对于更新的前一个节点</span><br><span class="hljs-string">            :param next: 相对于更新的后一个节点</span><br><span class="hljs-string">            :param val:  要添加的节点值</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 计数累加</span><br>        self._count += <span class="hljs-number">1</span><br>        node = Node(val)<br>        prev.<span class="hljs-built_in">next</span>, <span class="hljs-built_in">next</span>.prev = node, node<br>        node.prev, node.<span class="hljs-built_in">next</span> = prev, <span class="hljs-built_in">next</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deleteAtIndex</span>(<span class="hljs-params">self, index: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Delete the index-th node in the linked list, if the index is valid.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= index &lt; self._count:<br>            node = self._get_node(index)<br>            <span class="hljs-comment"># 计数-1</span><br>            self._count -= <span class="hljs-number">1</span><br>            node.prev.<span class="hljs-built_in">next</span>, node.<span class="hljs-built_in">next</span>.prev = node.<span class="hljs-built_in">next</span>, node.prev<br><br><span class="hljs-comment"># Your MyLinkedList object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = MyLinkedList()</span><br><span class="hljs-comment"># param_1 = obj.get(index)</span><br><span class="hljs-comment"># obj.addAtHead(val)</span><br><span class="hljs-comment"># obj.addAtTail(val)</span><br><span class="hljs-comment"># obj.addAtIndex(index,val)</span><br><span class="hljs-comment"># obj.deleteAtIndex(index)</span><br></code></pre></td></tr></table></figure>
<h4 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h4><p>要想进行链表的翻转，不是重新遍历（浪费内存空间），而是修改指针指向达到翻转的效果<br>例如双指针遍历，一次操作修改一次指针（为了统一程序的操作，采用虚拟头节点）<br>或者因为操作的内在一致性，可以想到使用递归的方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//双指针</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* temp;<br>        ListNode* cur = head;<br>        ListNode* pre = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">//cur为空时循环结束</span><br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            temp = cur-&gt;next; <span class="hljs-comment">//把当前下一节点的指向存起来</span><br>            cur-&gt;next = pre; <span class="hljs-comment">//指针翻转到上一节点</span><br>            pre = cur; <span class="hljs-comment">//向着翻转方向移动一位</span><br>            cur = temp; <span class="hljs-comment">//同理，移动一位</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>递归法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseList</span>(<span class="hljs-params">self, head: ListNode</span>) -&gt; ListNode:</span><br>        <span class="hljs-comment">#递归</span><br>        <span class="hljs-keyword">if</span> head == <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> head.<span class="hljs-built_in">next</span> == <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> head<br>        cur = self.reverseList(head.<span class="hljs-built_in">next</span>) <span class="hljs-comment">#一直递归到头，回溯返回head为最后的节点，给cur，此时head为倒数第二个节点</span><br>        head.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span> = head <span class="hljs-comment">#用head.next表示最后的节点，再把next指向当前的倒数第二节点，完成翻转</span><br>        head.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span> <span class="hljs-comment">#再把向后的指针青空</span><br>        <span class="hljs-keyword">return</span> cur <span class="hljs-comment">#向上一个递归循环返回当前cur（head） 但也是一直不变的head，用于最后输出</span><br></code></pre></td></tr></table></figure>
<h4 id="两两节点交换"><a href="#两两节点交换" class="headerlink" title="两两节点交换"></a>两两节点交换</h4><p>依据代码的完整性逻辑，一般不改变节点值，而是进行实际的交换<br><img data-fancybox="gallery" data-sizes="auto" data-src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B92.png" alt="交换方法" class="lazyload"></p>
<h4 id="删除链表的倒数N节点（三次AC）"><a href="#删除链表的倒数N节点（三次AC）" class="headerlink" title="删除链表的倒数N节点（三次AC）"></a>删除链表的倒数N节点（三次AC）</h4><p>双指针的经典应用，如果要删除【倒数】第n个节点：让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。（双指针对于位置距离的控制效果）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">removeNthFromEnd</span>(<span class="hljs-params">self, head, n</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type head: ListNode</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :rtype: ListNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 要想删除链表中的某个节点，就要把前一个节点的next指向下一个节点，出了c其他语言不需要回收内存</span><br>        <span class="hljs-comment"># 此处是删除倒数的链表节点，怎么样才能再不知道链表长度的情况下定位n呢，当然是用指针距离:要删除倒数第n个节点，pro距离cur必须为n</span><br>        <span class="hljs-comment"># 为了更好的计数统计，使用虚拟的头节点</span><br>        nhead = ListNode(<span class="hljs-literal">None</span>,head)<br>        cur = nhead<br>        pro = head <span class="hljs-comment">#前指针</span><br>        <span class="hljs-comment">#cur.next = head #后指针</span><br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-comment">#print(pro.next) #head原来就是第一个节点啊（写着写着恍然大悟）</span><br>        <span class="hljs-keyword">while</span> pro.<span class="hljs-built_in">next</span> != <span class="hljs-literal">None</span>: <span class="hljs-comment">#前指针停在最后一个节点，此时要删节点了，跳出循环</span><br>            pro = pro.<span class="hljs-built_in">next</span> <span class="hljs-comment">#前指针前进</span><br>             <span class="hljs-comment">#前指针移动了count次,</span><br>            count += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> count &gt;= n: <span class="hljs-comment">#跟着走</span><br>                cur = cur.<span class="hljs-built_in">next</span>    <br>        <span class="hljs-comment">#当pro到终点</span><br>        cur.<span class="hljs-built_in">next</span> = cur.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> nhead.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure>

<h4 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h4><p>&emsp;&emsp;问题：给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。（题目中确保了链表没有环结构）<br>思路：这一题就是求两个链表交点处的指针。</p>
<h4 id="环形链表II"><a href="#环形链表II" class="headerlink" title="环形链表II"></a>环形链表II</h4><h3 id="哈希表-（key-value-O1时间访问）"><a href="#哈希表-（key-value-O1时间访问）" class="headerlink" title="哈希表 （key:value/O1时间访问）"></a>哈希表 （key:value/O1时间访问）</h3><p>&emsp;&emsp;我理解的哈希表：<br>哈希表的本质：哈希(hash)映射算法，把传入的key值映射道符号表的索引上<br>哈希表的作用：快速查看元素是否出现在集合中（以时间换空间）<br>理解哈希函数的本质原理以及哈希碰撞在哈希表中的作用：多个key映射到相同索引上的情景，处理碰撞的普通方式是拉链法和线性探测法。</p>
<p>&emsp;&emsp;常见的三种哈希结构：数组，set，map<br>哈希表常考题型：给数据搜索数据中的某些元素或者寻求建立对应关系的题型，但凡涉及某个元素搜索的时空复杂度，都可以考虑哈希。</p>
<h4 id="有效字母异位词"><a href="#有效字母异位词" class="headerlink" title="有效字母异位词"></a>有效字母异位词</h4><p>&emsp;&emsp;数组就是固定大小的简单哈希表，可以考虑采用相对数值计数的方法，给一个带下标的数组（哈希表）里不断计某个字母出现的次数，这样就可以判断这些字母是否共有，还能通过减操作判断其是否可以完美还原和复原其字母异位词。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#字母异位存在问题可以通过计数解决，也就是看两个字符串字母出现的次数是否相等，以下是伪代码</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isAnagram</span>(<span class="hljs-params">self, s, l</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :type t: str</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment">#定义一个用来表示26个字母的数组（哈希表）</span><br>        recode = [<span class="hljs-number">0</span>]*<span class="hljs-number">26</span><br>        <span class="hljs-comment">#原字符串输入遍历记录 python中的ord是用来返回变量对应的ascall码</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            recode[<span class="hljs-built_in">ord</span>(s[i]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)] += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(l)):<br>            recode[<span class="hljs-built_in">ord</span>(l[j]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)] -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">26</span>):<br>            <span class="hljs-keyword">if</span> recode[k] != <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <br></code></pre></td></tr></table></figure>
<h4 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h4><p>题意：给定两个数组，编写一个函数来计算它们的交集。<br>这里要学一种结构：unordered_set 用于解决不考虑输出结果顺序的情况<br>值得注意的地方是数组是有限简单哈希表，这里没有著名数据的限制，所以无法使用数组而使用集合set(set预设占用空间比数组大，而且也比数组慢)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-keyword">int</span>&gt; result_set; <span class="hljs-comment">// 存放结果</span><br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">nums_set</span><span class="hljs-params">(nums1.begin(), nums1.end())</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums2) &#123;<br>            <span class="hljs-comment">// 发现nums2的元素 在nums_set里又出现过</span><br>            <span class="hljs-keyword">if</span> (nums_set.<span class="hljs-built_in">find</span>(num) != nums_set.<span class="hljs-built_in">end</span>()) &#123;<br>                result_set.<span class="hljs-built_in">insert</span>(num);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-keyword">int</span>&gt;(result_set.<span class="hljs-built_in">begin</span>(), result_set.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h4><p>题意：编写一个算法来判断一个数 n 是不是快乐数。</p>
<p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python">```<br><span class="hljs-comment">#### 两数之和（下边刷题拓展4）</span><br>【基本】两数之和问题：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。<br>```python<br><span class="hljs-comment">#自己的思路</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span>(<span class="hljs-params">self, nums, target</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :type nums: List[int]</span><br><span class="hljs-string">    :type target: int</span><br><span class="hljs-string">    :rtype: List[int]</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment">#内置函数enumerate()将数组等转化为可遍历序列</span><br>    <span class="hljs-comment">#要解决两数和还要知道下标索引，自然是采用map和哈希</span><br>    record = <span class="hljs-built_in">dict</span>()<br>    <span class="hljs-keyword">for</span> idx, val <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>        <span class="hljs-comment">#值和下标一起遍历nums,找另一半是否在，不在就先存起来,记得存的是下标</span><br>        <span class="hljs-keyword">if</span> target - val <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> record:<br>            record[val] = idx<br>        <span class="hljs-keyword">else</span>: <br>            <span class="hljs-comment">#如果在，说明之前存过了，都输出来即可</span><br>            <span class="hljs-keyword">return</span> [record[target - val], idx]<br></code></pre></td></tr></table></figure>
<p>一般暴力解法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:</span><br>    n = <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, n):<br>            <span class="hljs-keyword">if</span> nums[i] + nums[j] == target:<br>                <span class="hljs-keyword">return</span> [i, j]<br>    <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure>
<h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h4><p>三数问题不同于两数问题，其中涉及去重是一个很复杂的工作，所以除非是返回数的下标索引这种不考虑动原数组的情况外，其他情况都考虑进行排序和双指针操作便于一开始就通过位置关系进行去重</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">threeSum</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment">#做三数问题，首先思路清晰方法对</span><br>        <span class="hljs-comment">#首先对nums进行排序</span><br>        nums.sort()<br>        res = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>):<br>            <span class="hljs-comment">#固定住了遍历位，等于后面找两个相加等于-nums[i]</span><br>            left = i + <span class="hljs-number">1</span><span class="hljs-comment">#避免重复</span><br>            right = <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span><br>            <span class="hljs-comment">#解决一些首部出现连续相同数字的情况</span><br>            <span class="hljs-keyword">if</span> nums[i] &gt; <span class="hljs-number">0</span>: <span class="hljs-comment">#排序后可知</span><br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> nums[i] == nums[i-<span class="hljs-number">1</span>]: <span class="hljs-comment">#找最后那个不重复的i开始</span><br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">while</span> left &lt; right:<br>                <span class="hljs-comment">#没找到三数，左也小于右那就一直找</span><br>                <span class="hljs-keyword">if</span> nums[left] + nums[right] + nums[i] == <span class="hljs-number">0</span>:<br>                    res.append([nums[i],nums[left],nums[right]])<br>                    <span class="hljs-comment">#此时也要判断是否只有这一个，局部去重</span><br>                    <span class="hljs-keyword">while</span> left != right <span class="hljs-keyword">and</span> nums[left] == nums[left+<span class="hljs-number">1</span>]:<br>                        left += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">while</span> left != right <span class="hljs-keyword">and</span> nums[right] == nums[right-<span class="hljs-number">1</span>]:<br>                        right -= <span class="hljs-number">1</span><br>                    left += <span class="hljs-number">1</span><br>                    right -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">elif</span> nums[left] + nums[right] + nums[i] &lt; <span class="hljs-number">0</span>:<br>                    left += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    right -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
<h4 id="多位数的和与加"><a href="#多位数的和与加" class="headerlink" title="多位数的和与加"></a>多位数的和与加</h4><h4 id="赎金信问题"><a href="#赎金信问题" class="headerlink" title="赎金信问题"></a>赎金信问题</h4><p>题意：给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。<br>其实这道题和字母异位词问题很相似，都是求互相组成和成分查找的问题，自然而然首先想到使用哈希表。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h4><p>将字符串转换成数组（自带“，”拆分），循环双头遍历互换实现字符串翻转，进阶问题就是添加一些判断条件和给题目加理解陷阱，如下翻转字符串||</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseStr</span>(<span class="hljs-params">self, s, k</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment">#长题目一定要梳理题意，本题就是要按2K长度切分字符串，然后把前半K翻转过来，剩下的不够也翻转，够了就翻转前半K</span><br>        res = <span class="hljs-built_in">list</span>(s)<br>        <span class="hljs-comment"># 设计局部翻转函数</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse_str</span>(<span class="hljs-params">text</span>):</span><br>            left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(text) - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> left &lt; right:<br>                text[left], text[right] = text[right], text[left]<br>                left += <span class="hljs-number">1</span><br>                right -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> text<br>        <span class="hljs-comment">#遍历切分：这里是我还不会的局部切分步骤</span><br>        <span class="hljs-keyword">for</span> cur <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(s), <span class="hljs-number">2</span>*k):<br>            <span class="hljs-built_in">print</span>(cur)<br>            res[cur: cur + k] = reverse_str(res[cur: cur + k])<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.join(res)<br>        <span class="hljs-comment">#先把问题模块化，这样最容易得到公共部分建立函数的思想以达到最简化程序的效果</span><br></code></pre></td></tr></table></figure>
<h4 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h4><p>代码思路：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">replaceSpace</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:</span><br>        counter = s.count(<span class="hljs-string">&#x27; &#x27;</span>)<br>        <br>        res = <span class="hljs-built_in">list</span>(s)<br>        <span class="hljs-comment"># 每碰到一个空格就多拓展两个格子，1 + 2 = 3个位置存’%20‘</span><br>        res.extend([<span class="hljs-string">&#x27; &#x27;</span>] * counter * <span class="hljs-number">2</span>)<br>        <br>        <span class="hljs-comment"># 原始字符串的末尾，拓展后的末尾</span><br>        left, right = <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(res) - <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">while</span> left &gt;= <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> res[left] != <span class="hljs-string">&#x27; &#x27;</span>:<br>                res[right] = res[left]<br>                right -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># [right - 2, right), 左闭右开</span><br>                res[right - <span class="hljs-number">2</span>: right + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;%20&#x27;</span><br>                right -= <span class="hljs-number">3</span><br>            left -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(res)<br></code></pre></td></tr></table></figure>
<h4 id="比较字符串的大小"><a href="#比较字符串的大小" class="headerlink" title="比较字符串的大小"></a>比较字符串的大小</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/compare-version-numbers/">给你两个版本号 version1 和 version2 ，请你比较它们</a></p>
<p>版本号由一个或多个修订号组成，各修订号由一个 ‘.’ 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。</p>
<p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。</p>
<p>返回规则如下：</p>
<p>如果 version1 &gt; version2 返回 1，<br>如果 version1 &lt; version2 返回 -1，<br>除此之外返回 0。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compareVersion</span>(<span class="hljs-params">self, version1, version2</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type version1: str</span><br><span class="hljs-string">        :type version2: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment">#先进行版号分割，再逐一对比</span><br>        v1 = version1.split(<span class="hljs-string">&quot;.&quot;</span>)<br>        v2 = version2.split(<span class="hljs-string">&quot;.&quot;</span>)<br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt;= <span class="hljs-built_in">max</span>(<span class="hljs-built_in">len</span>(v1)-<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(v2)-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> i &lt;= <span class="hljs-built_in">len</span>(v1)-<span class="hljs-number">1</span>:<br>                d1 = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(v1[i])):<br>                    d1 +=  (<span class="hljs-built_in">ord</span>(v1[i][-j-<span class="hljs-number">1</span>]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;0&#x27;</span>)) * (<span class="hljs-number">10</span> ** j) <span class="hljs-comment">#对比字符串的的ascall码</span><br>                <span class="hljs-built_in">print</span>(d1)<br>            <span class="hljs-keyword">else</span>:<br>                d1 = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">if</span> i &lt;= <span class="hljs-built_in">len</span>(v2)-<span class="hljs-number">1</span>:<br>                d2 = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(v2[i])):<br>                    d2 +=  (<span class="hljs-built_in">ord</span>(v2[i][-j-<span class="hljs-number">1</span>]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;0&#x27;</span>)) * (<span class="hljs-number">10</span> ** j)<br>                <span class="hljs-built_in">print</span>(d2)<br>            <span class="hljs-keyword">else</span>:<br>                d2 = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">if</span> d1 &gt; d2:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> d2 &gt; d1:<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<h4 id="翻转字符串中的单词"><a href="#翻转字符串中的单词" class="headerlink" title="翻转字符串中的单词"></a>翻转字符串中的单词</h4><h4 id="左旋转字符"><a href="#左旋转字符" class="headerlink" title="左旋转字符"></a>左旋转字符</h4><h4 id="实现sreStr"><a href="#实现sreStr" class="headerlink" title="实现sreStr()"></a>实现sreStr()</h4><h4 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h4><h4 id="无重复最长子串（三次AC）"><a href="#无重复最长子串（三次AC）" class="headerlink" title="无重复最长子串（三次AC）"></a>无重复最长子串（三次AC）</h4><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p>这个方法的好处就是只用遍历一次（O（n））而且不用针对每个元素找其最长子串，直接找，重复了就扔（至于为什么，因为两个相同的字母间隔决定了串长，要想更长，只能丢前找后）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        <span class="hljs-comment">#找子串肯定少不了遍历，最高要求就是一次遍历，要得到最长长度，想到滑动窗口，但应该还有不用遍历每个元素的方法</span><br>        s = <span class="hljs-built_in">list</span>(s)<br>        <span class="hljs-comment"># 简单直接去求这个子串(遍历的时候一直装不同的字母，直到重复字母出现，记下此时的长度，并把原来那一节丢掉，再往后继续装)</span><br>        res = []<br>        temp = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-comment">#print(i)</span><br>            <span class="hljs-keyword">if</span> s[i] <span class="hljs-keyword">in</span> res:<br>                <span class="hljs-comment">#print(&quot;判断&quot;+str(s[i])+&#x27;在&#x27;+str(res))</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) &gt; temp: <span class="hljs-comment">#更新最大值</span><br>                    temp = <span class="hljs-built_in">len</span>(res)<br>                    <span class="hljs-comment">#print(&quot;局部最大子串&quot;+str(res)+str(temp))</span><br>                <span class="hljs-comment">#已经有重复了，要把之前的斩掉</span><br>                idx = res.index(s[i])<br>                <span class="hljs-comment">#print(&quot;删去前：&quot;+str(res))</span><br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> res[:idx+<span class="hljs-number">1</span>]:<br>                    res.remove(j)<br>                    <span class="hljs-comment">#print(&quot;删去后：&quot;+str(res))</span><br>            res.append(s[i]) <span class="hljs-comment">#再把这个i放进去</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) &lt;= temp:<br>            <span class="hljs-keyword">return</span> temp<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(res)<br></code></pre></td></tr></table></figure>
<p>滑动窗口法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><br></code></pre></td></tr></table></figure>
<h4 id="字符中的最长回文子串"><a href="#字符中的最长回文子串" class="headerlink" title="字符中的最长回文子串"></a>字符中的最长回文子串</h4><h3 id="数据结构：栈、堆、队列"><a href="#数据结构：栈、堆、队列" class="headerlink" title="数据结构：栈、堆、队列"></a>数据结构：栈、堆、队列</h3><p>栈：数据先进后出的存储方式<br>堆：堆是一种常见的树形结构，是一种特殊的完全二叉树，当且仅当满足所有节点的值总是不大于或不小于其父节点的值的完全二叉树被称之为堆。堆的这一种特性称之为堆序性（顾名思义，就是用树串（堆）起来的一坨东西）因此，在一个堆中，根节点是最大（或最小）节点。如果根节点最小，称之为小顶堆（或小根堆），如果根节点最大，称之为大顶堆（或大根堆）。堆的左右孩子没有大小的顺序。有最大堆或者最小堆的说法。<br>队列：数据先进先出的存储方式<br><img src="https://img-blog.csdnimg.cn/20210104235346563.png"></p>
<h4 id="有效括号问题"><a href="#有效括号问题" class="headerlink" title="有效括号问题"></a>有效括号问题</h4><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：<br>    左括号必须用相同类型的右括号闭合。<br>    左括号必须以正确的顺序闭合。<br>    注意空字符串可被认为是有效字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isValid</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        stack = []<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> item == <span class="hljs-string">&quot;(&quot;</span>:<br>                stack.append(<span class="hljs-string">&quot;)&quot;</span>)<br>            <span class="hljs-keyword">elif</span> item == <span class="hljs-string">&quot;[&quot;</span>:<br>                stack.append(<span class="hljs-string">&quot;]&quot;</span>)<br>            <span class="hljs-keyword">elif</span> item == <span class="hljs-string">&quot;&#123;&quot;</span>:<br>                stack.append(<span class="hljs-string">&quot;&#125;&quot;</span>)<br>            <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> stack <span class="hljs-keyword">or</span> stack[-<span class="hljs-number">1</span>] != item:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">else</span>:<br>                stack.pop()<br>        <span class="hljs-comment">#print(stack)</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> stack:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>
<h4 id="碰碰消：删除字符串中所有的相邻重复游戏"><a href="#碰碰消：删除字符串中所有的相邻重复游戏" class="headerlink" title="碰碰消：删除字符串中所有的相邻重复游戏"></a>碰碰消：删除字符串中所有的相邻重复游戏</h4><p><img src="https://code-thinking.cdn.bcebos.com/gifs/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.gif"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">removeDuplicates</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = <span class="hljs-built_in">list</span>()<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> res <span class="hljs-keyword">and</span> res[-<span class="hljs-number">1</span>] == item:<br>                res.pop()<br>            <span class="hljs-keyword">else</span>:<br>                res.append(item)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.join(res)<br></code></pre></td></tr></table></figure>

<h3 id="二叉树-递归"><a href="#二叉树-递归" class="headerlink" title="二叉树/递归"></a>二叉树/递归</h3><p>二叉树是计算机底层的一种数据结构，有两大种类：满二叉树和完全二叉树<br><img data-fancybox="gallery" data-sizes="auto" data-src="https://bkimg.cdn.bcebos.com/pic/71cf3bc79f3df8dc1e9d5e85c211728b47102806?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U5Mg==,g_7,xp_5,yp_5/format,f_auto," alt="二叉树结构" class="lazyload"><br>根据有无数据，又数据的又称为二叉搜索树，为有序树，有以下特点：</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉排序树<br>存储方式可以是数组，也可以是链表<h4 id="二叉树的遍历（遍历问题学习递归，迭代的思想）"><a href="#二叉树的遍历（遍历问题学习递归，迭代的思想）" class="headerlink" title="二叉树的遍历（遍历问题学习递归，迭代的思想）"></a>二叉树的遍历（遍历问题学习递归，迭代的思想）</h4></li>
</ul>
<table>
<thead>
<tr>
<th>前序</th>
<th>中序</th>
<th>后序</th>
</tr>
</thead>
<tbody><tr>
<td>中左右</td>
<td>左中右</td>
<td>左右中</td>
</tr>
<tr>
<td>从上到下</td>
<td>从左到右</td>
<td>从下倒上</td>
</tr>
</tbody></table>
<p><strong>递归遍历：无限万花镜</strong><br>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p>
<p>遇到过一种错误就是栈溢出，系统输出的异常是Segmentation fault（当然不是所有的Segmentation fault 都是栈溢出导致的） ，如果你使用了递归，就要想一想是不是无限递归了，那么系统调用栈就会溢出。</p>
<p>而且<strong>在企业项目开发中，尽量不要使用递归！</strong>在项目比较大的时候，由于参数多，全局变量等等，使用递归很容易判断不充分return的条件，非常容易无限递归（或者递归层级过深），造成栈溢出错误（这种问题还不好排查！）</p>
<p>我所理解的递归的根本思想就是函数“自我”的无限反复嵌套和不断进行穿参“求导”，直到最终求出最终的子节点（或者到达递归终点return回去的时候就变成了回溯），这就相当于把所有的节点按函数规定遍历的顺序遍历了一遍，拓展到同类问题也是一样的，当涉及到某一函数的大量重复调用的时候，也就是递归思想起作用的时候~</p>
<p>但迭代的本质依然是使用了栈的思想，每一次的递归调用都会把局部的变量，参数以及返回值压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p>
<p>经典代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//1.确定递归函数的具体参数和返回值</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">digui</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; vec)</span></span><br><span class="hljs-function"><span class="hljs-comment">//2.确定终止条件</span></span><br><span class="hljs-function">    <span class="hljs-title">if</span> <span class="hljs-params">(cur == <span class="hljs-literal">NULL</span>)</span> <span class="hljs-keyword">return</span></span>;<br><span class="hljs-comment">//3.确定单层递归的逻辑（带着不断递归来的参数在某一层应该怎么样操作，并且如何进行递归返回得到需要的结果）</span><br>    vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<span class="hljs-comment">//收集当前值</span><br>    <span class="hljs-built_in">digui</span>(cur-&gt;left, vec);<span class="hljs-comment">//遍历左边</span><br>    <span class="hljs-built_in">digui</span>(cur-&gt;right, vec);<span class="hljs-comment">//遍历右边</span><br></code></pre></td></tr></table></figure>
<p><strong>迭代遍历：深度搜索</strong><br>迭代顾名思义，用某种固定的方式函数对目标进行操作，和递归有相似之处（迭代更灵活一点）<br>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。<br><strong>迭代过程一定会用到栈操作，必须注意出入栈的顺序</strong><br>经典代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; st;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; result;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();                       <span class="hljs-comment">// 中</span><br>            st.<span class="hljs-built_in">pop</span>();<br>            result.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);           <span class="hljs-comment">// 右（空节点不入栈）</span><br>            <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);             <span class="hljs-comment">// 左（空节点不入栈）</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>层序遍历：广度搜索</strong><br>就是从左到右一层一层的去遍历二叉树，需要借助一个辅助数据结构队列来实现，队列先进先出，符合一层一层遍历逻辑：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnad5itmk8g30iw0cqe83.gif"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;二叉树层序遍历迭代解法&quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">levelOrder</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:</span><br>        results = []<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> results<br>        <br>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br>        que = deque([root]) <span class="hljs-comment">#把二叉树装进队列中</span><br>        <br>        <span class="hljs-keyword">while</span> que:<br>            size = <span class="hljs-built_in">len</span>(que)<br>            result = []<br>            <span class="hljs-comment">#从头到尾，pop根append左右，最终直到que里没有节点</span><br>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size):<br>                cur = que.popleft() <span class="hljs-comment">#当前节点从左边丢出去</span><br>                result.append(cur.val) <span class="hljs-comment">#记录每个出来的点，就是层序节点值</span><br>                <span class="hljs-keyword">if</span> cur.left:<br>                    que.append(cur.left) <span class="hljs-comment">#子节点从右边捡回来</span><br>                <span class="hljs-keyword">if</span> cur.right:<br>                    que.append(cur.right)<br>            results.append(result)<br><br>        <span class="hljs-keyword">return</span> results<br></code></pre></td></tr></table></figure>
<p>例题：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">填充每个节点的下一个右侧节点指针</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connect</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Node</span><br><span class="hljs-string">        :rtype: Node</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment">#每一层的连接，广度搜索</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>            <span class="hljs-keyword">return</span> root<br>        Q = collections.deque([root]) <span class="hljs-comment">#第一层加入队列</span><br>        <span class="hljs-keyword">while</span> Q:<br>            size = <span class="hljs-built_in">len</span>(Q)<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size): <span class="hljs-comment">#遍历这一层所有的节点</span><br>                node = Q.popleft() <span class="hljs-comment">#一般会pop左节点出来</span><br>                <span class="hljs-keyword">if</span> i &lt; size - <span class="hljs-number">1</span>:<br>                    node.<span class="hljs-built_in">next</span> = Q[<span class="hljs-number">0</span>] <span class="hljs-comment">#等于右节点</span><br>                <span class="hljs-keyword">if</span> node.left:<br>                    Q.append(node.left) <span class="hljs-comment">#添加节点作为下一层计算</span><br>                <span class="hljs-keyword">if</span> node.right:<br>                    Q.append(node.right)<br>        <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure>
<p>锯齿遍历</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root: <span class="hljs-comment">#如果树的节点是空的，返回[]即可</span><br>            <span class="hljs-keyword">return</span> []<br>        res = [] <span class="hljs-comment">#初始化一个返回列表</span><br>        q = collections.deque() <span class="hljs-comment">#初始化一个双边队列</span><br>        q.append(root) <span class="hljs-comment">#首先将根节点压入双边队列中</span><br>        <span class="hljs-keyword">while</span> q: <span class="hljs-comment">#因为我们的目的就是将所有的节点遍历到，所以结束条件就是队列为空</span><br>            res_tmp = [] <span class="hljs-comment">#因为题目要求返回的是按照层划分的数组，所以这边需要一个过渡数组</span><br>            n = <span class="hljs-built_in">len</span>(q) <span class="hljs-comment">#首先记录一下该层的长度，因为是每一层单边遍历记录，所以需要知道该层的长度</span><br><span class="hljs-comment">#因为队列还在不停的往里面压入这些节点的子孩子，所以q的长度是变化的，所以这边需要提前记录一下</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n): <span class="hljs-comment">#将每行所有的节点全部遍历到</span><br>                tmp = q.popleft() <span class="hljs-comment">#首先将最左边的队列元素弹出</span><br>                res_tmp.append(tmp.val) <span class="hljs-comment">#将弹出的节点值压入每行的过渡数组中</span><br>                <span class="hljs-keyword">if</span> tmp.left: <span class="hljs-comment">#如果当前节点存在左子树</span><br>                    q.append(tmp.left) <span class="hljs-comment">#就把相应的左子树放入到队列中作为下一层待遍历的节点</span><br>                <span class="hljs-keyword">if</span> tmp.right:<span class="hljs-comment">#如果当前节点存在右子树</span><br>                    q.append(tmp.right)<span class="hljs-comment">#就把相应的右子树放入到队列中作为下一层待遍历的节点</span><br>            res.append(res_tmp) <span class="hljs-comment">#每层遍历结束，就将该层的遍历结果放入到最终的输出数组中</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(res)): <span class="hljs-comment">#因为要求是锯齿遍历，所以要把偶数行给翻转一下</span><br>            <span class="hljs-keyword">if</span> j % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>: <span class="hljs-comment">#因为索引是从0开始的，所以这边判断余数是否为1</span><br>                res[j].reverse() <span class="hljs-comment">#如果是第偶数行，翻转，reverse是一个自带的反转函数，蛮好用的</span><br>                <br>        <span class="hljs-keyword">return</span> res <span class="hljs-comment">#返回最终值即可</span><br></code></pre></td></tr></table></figure>
<h4 id="二叉树的属性"><a href="#二叉树的属性" class="headerlink" title="二叉树的属性"></a>二叉树的属性</h4><ol>
<li>对称性：二叉树各内外侧（左右子节点）严格依据根节点为中轴轴对称</li>
<li>最大深度：根节点到树子节点的最长距离</li>
<li>最小深度：树子节点到根节点的最小距离</li>
<li>完全二叉树：左右子节点都存在的二叉树</li>
<li>平衡二叉树：左右两个子树的高度差的绝对值不超过1</li>
<li>二叉树的所有路径：<br><img data-fancybox="gallery" data-sizes="auto" data-src="https://img-blog.csdnimg.cn/20210204151702443.png" alt="所有路径图解" class="lazyload"></li>
<li>左叶子之和：注意判别左子叶的存在性，然后再进行遍历</li>
<li>找树左下角的值：本地要找出树的最后一行找到最左边的值。此时大家应该想起用层序遍历是非常简单的了，反而用递归的话会比较难一点。</li>
<li>树的路径总和：遍历的时候刻画路径<h5 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h5>二叉树：是否对称(opens new window)<br>递归：后序，比较的是根节点的左子树与右子树是不是相互翻转<br>迭代：使用队列/栈将两个节点顺序放入容器中进行比较<br>二叉树：求最大深度(opens new window)<br>递归：后序，求根节点最大高度就是最大深度，通过递归函数的返回值做计算树的高度<br>迭代：层序遍历<br>二叉树：求最小深度(opens new window)<br>递归：后序，求根节点最小高度就是最小深度，注意最小深度的定义<br>迭代：层序遍历<br>二叉树：求有多少个节点(opens new window)<br>递归：后序，通过递归函数的返回值计算节点数量<br>迭代：层序遍历<br>二叉树：是否平衡(opens new window)<br>递归：后序，注意后序求高度和前序求深度，递归过程判断高度差<br>迭代：效率很低，不推荐<br>二叉树：找所有路径(opens new window)<br>递归：前序，方便让父节点指向子节点，涉及回溯处理根节点到叶子的所有路径<br>迭代：一个栈模拟递归，一个栈来存放对应的遍历路径<br>二叉树：递归中如何隐藏着回溯(opens new window)<br>详解二叉树：找所有路径 (opens new window)中递归如何隐藏着回溯<br>二叉树：求左叶子之和(opens new window)<br>递归：后序，必须三层约束条件，才能判断是否是左叶子。<br>迭代：直接模拟后序遍历<br>二叉树：求左下角的值(opens new window)<br>递归：顺序无所谓，优先左孩子搜索，同时找深度最大的叶子节点。<br>迭代：层序遍历找最后一行最左边<br>二叉树：求路径总和(opens new window)<br>递归：顺序无所谓，递归函数返回值为bool类型是为了搜索一条边，没有返回值是搜索整棵树。<br>迭代：栈里元素不仅要记录节点指针，还要记录从头结点到该节点的路径数值总和<h4 id="二叉树的修改与构造"><a href="#二叉树的修改与构造" class="headerlink" title="二叉树的修改与构造"></a>二叉树的修改与构造</h4></li>
</ol>
<ul>
<li>翻转二叉树</li>
<li>构造二叉树（从中序遍历或者是后序遍历）</li>
<li>最大二叉树</li>
<li>合并二叉树<br>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。<br>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</li>
</ul>
<p>思路：遍历操作，同事传入两个树的节点，同时操作。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbjjq8h16g30e20cwnpd.gif"></p>
<h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>二叉搜索树中的插入操作(opens new window)<br>递归：顺序无所谓，通过递归函数返回值添加节点<br>迭代：按序遍历，需要记录插入父节点，这样才能做插入操作<br>二叉搜索树中的删除操作(opens new window)<br>递归：前序，想清楚删除非叶子节点的情况<br>迭代：有序遍历，较复杂<br>修剪二叉搜索树(opens new window)<br>递归：前序，通过递归函数返回值删除节点<br>迭代：有序遍历，较复杂<br>构造二叉搜索树(opens new window)<br>递归：前序，数组中间节点分割<br>迭代：较复杂，通过三个队列来模拟</p>
<h4 id="求二叉搜索树的属性"><a href="#求二叉搜索树的属性" class="headerlink" title="求二叉搜索树的属性"></a>求二叉搜索树的属性</h4><ul>
<li>二叉搜索树是一个有序树：<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉搜索树</li>
</ul>
</li>
</ul>
<p><strong>这就决定了，二叉搜索树，递归遍历和迭代遍历和普通二叉树都不一样。</strong></p>
<p>红黑树又叫平衡二叉搜索树，但它是在计算机科学中用来组织数据比如数字的块的一种结构。红黑树是一种平衡二叉查找树的变体，它的左右子树高差有可能大于1，所以红黑树不是严格意义上的平衡二叉搜索树。</p>
<ol>
<li><p>二叉搜索树中的搜索<br>搜索二叉树节点中的某个值，并返回以该节点为根的子树。如果节点不存在，则返回NULL</p>
</li>
<li><p>验证二叉搜索树<br>知道中序遍历下，输出的二叉搜索树节点的数值是有序序列。<br>有了这个特性，验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。</p>
</li>
<li><p>二叉搜索树中的绝对误差</p>
</li>
<li><p>二叉搜索树中的众数</p>
</li>
<li><p>把二叉搜索树转换为累加树</p>
</li>
</ol>
<h4 id="公共祖先问题"><a href="#公共祖先问题" class="headerlink" title="公共祖先问题"></a>公共祖先问题</h4><ol>
<li>二叉树的最近公共祖先<br>递归：后序，回溯，找到左子树出现目标值，右子树节点目标值的节点。<br>迭代：不适合模拟回溯<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;二叉树的最近公共祖先 递归法&quot;&quot;&quot;</span><br>    <span class="hljs-comment">#递归思考，有返回值（祖先），参数（逐层遍历的root），单层：搜索，找到后返回</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lowestCommonAncestor</span>(<span class="hljs-params">self, root: <span class="hljs-string">&#x27;TreeNode&#x27;</span>, p: <span class="hljs-string">&#x27;TreeNode&#x27;</span>, q: <span class="hljs-string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root <span class="hljs-keyword">or</span> root == p <span class="hljs-keyword">or</span> root == q: <span class="hljs-comment">#寻找目标节点</span><br>            <span class="hljs-keyword">return</span> root<br>        <br>        left = self.lowestCommonAncestor(root.left, p, q)<br>        right = self.lowestCommonAncestor(root.right, p, q)<br>        <br>        <span class="hljs-keyword">if</span> left <span class="hljs-keyword">and</span> right: <span class="hljs-comment">#两边都有返回值，说明找到了祖先当前root</span><br>            <span class="hljs-keyword">return</span> root<br>        <span class="hljs-keyword">if</span> left:<br>            <span class="hljs-keyword">return</span> left<br>        <span class="hljs-keyword">return</span> right<br></code></pre></td></tr></table></figure></li>
<li>二叉搜索树的最近公共祖先<br>递归：顺序无所谓，如果节点的数值在目标区间就是最近公共祖先<br>迭代：按序遍历<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lowestCommonAncestor</span>(<span class="hljs-params">self, root, p, q</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :type p: TreeNode</span><br><span class="hljs-string">        :type q: TreeNode</span><br><span class="hljs-string">        :rtype: TreeNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment">#依然采用递归的遍历迭代方法，但只要求找到root的值在p,q之间</span><br>        <span class="hljs-keyword">if</span> root.val &gt; p.val <span class="hljs-keyword">and</span> root.val &gt; q.val:<br>            left = self.lowestCommonAncestor(root.left,p,q)<span class="hljs-comment">#root大过右边了</span><br>            <span class="hljs-keyword">return</span> left<br>        <span class="hljs-keyword">if</span> root.val &lt; p.val <span class="hljs-keyword">and</span> root.val &lt; q.val: <span class="hljs-comment">#root小过左边了</span><br>            right = self.lowestCommonAncestor(root.right,p,q)<br>            <span class="hljs-keyword">return</span> right<br>        <span class="hljs-keyword">return</span> root <span class="hljs-comment">#只为了找一个点然后递归返回</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="二叉树的修改与构造-1"><a href="#二叉树的修改与构造-1" class="headerlink" title="二叉树的修改与构造"></a>二叉树的修改与构造</h4><ol>
<li>二叉搜索树中的插入操作</li>
<li>删除二叉搜索树中的节点</li>
<li>修剪二叉搜索树</li>
<li>将有序数组转换为二叉搜索树<h4 id="解题思路总结"><a href="#解题思路总结" class="headerlink" title="解题思路总结"></a>解题思路总结</h4>二叉搜索树中的插入操作(opens new window)<br>递归：顺序无所谓，通过递归函数返回值添加节点<br>迭代：按序遍历，需要记录插入父节点，这样才能做插入操作<br>二叉搜索树中的删除操作(opens new window)<br>递归：前序，想清楚删除非叶子节点的情况<br>迭代：有序遍历，较复杂<br>修剪二叉搜索树(opens new window)<br>递归：前序，通过递归函数返回值删除节点<br>迭代：有序遍历，较复杂<br>构造二叉搜索树(opens new window)<br>递归：前序，数组中间节点分割<br>迭代：较复杂，通过三个队列来模拟</li>
</ol>
<h2 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h2><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><h4 id="什么是贪心"><a href="#什么是贪心" class="headerlink" title="什么是贪心"></a>什么是贪心</h4><p>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</p>
<p>这么说有点抽象，来举一个例子：</p>
<ol>
<li>例如，有一堆钞票，你可以拿走十张，如果想达到最大的金额，你要怎么拿？指定每次拿最大的，最终结果就是拿走最大数额的钱。每次拿最大的就是局部最优，最后拿走最大数额的钱就是推出全局最优。</li>
<li>再举一个例子如果是 有一堆盒子，你有一个背包体积为n，如何把背包尽可能装满，如果还每次选最大的盒子，就不行了。这时候就需要动态规划。动态规划的问题在下一个系列会详细讲解。</li>
</ol>
<h4 id="分发饼干问题"><a href="#分发饼干问题" class="headerlink" title="分发饼干问题"></a>分发饼干问题</h4><p>tips：当你想到要用双循环暴力解决问题的时候，看看能否可以只用一个循环就能完成两个量的转换</p>
<p>leetcode题目描述：<br>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p>我的题解代码：（暴力双循环遍历：一般来说容易超时）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findContentChildren</span>(<span class="hljs-params">self, g, s</span>):</span><br>        <br>        <span class="hljs-comment"># :type g: List[int]</span><br>        <span class="hljs-comment"># :type s: List[int]</span><br>        <span class="hljs-comment"># :rtype: int</span><br>        <br>        <span class="hljs-comment">#先给两个数组进行重排</span><br>        gg = <span class="hljs-built_in">sorted</span>(g)<br>        <span class="hljs-comment">#print(gg)</span><br>        ss = <span class="hljs-built_in">sorted</span>(s)<br>        <span class="hljs-comment">#print(ss)</span><br>        <span class="hljs-comment"># 双重遍历知否满足</span><br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> gg: <span class="hljs-comment">#给每个孩子发饼干</span><br>            <span class="hljs-built_in">print</span>(ss)<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> ss:<br>                <span class="hljs-keyword">if</span> j &gt;= i:<br>                    <span class="hljs-comment">#饼干每吃一块就少一块,python有三种删除节点的方法，list.remove():删除某个元素 del list[i]：删除某个下标元素 list.pop(i):栈的抛出</span><br>                    ss.remove(j)<br>                    count += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">return</span> count<br></code></pre></td></tr></table></figure>
<p>随想录题解：思路是这样的，贪心的地方是大饼干就先满足胃口大的孩子，所以顺序数组里遍历大胃口的孩纸后吃掉的同时索引也能递减1，用下一块大饼满足下一大胃王，直到最后遍历结束</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findContentChildren</span>(<span class="hljs-params">self, g, s</span>):</span><br>        <br>        <span class="hljs-comment"># :type g: List[int]</span><br>        <span class="hljs-comment"># :type s: List[int]</span><br>        <span class="hljs-comment"># :rtype: int</span><br>        <br>        gg = <span class="hljs-built_in">sorted</span>(g)<br>        ss = <span class="hljs-built_in">sorted</span>(s)<br>        count = <span class="hljs-number">0</span><br>        index = <span class="hljs-built_in">len</span>(ss) - <span class="hljs-number">1</span><br>        i = <span class="hljs-built_in">len</span>(gg) - <span class="hljs-number">1</span><br>        <span class="hljs-comment">#print(index)</span><br>        <span class="hljs-comment">#排序可以值得知道有序遍历的结果</span><br>        <span class="hljs-keyword">while</span> index &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> i &gt;= <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span>  ss[index] &gt;= gg[i]:<br>                count += <span class="hljs-number">1</span><br>                index -= <span class="hljs-number">1</span> <span class="hljs-comment">#索引跟着目录递减</span><br>            i -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> count<br></code></pre></td></tr></table></figure>
<h4 id="摆动序列问题：独立做出来的第一道中等题"><a href="#摆动序列问题：独立做出来的第一道中等题" class="headerlink" title="摆动序列问题：独立做出来的第一道中等题"></a>摆动序列问题：独立做出来的第一道中等题</h4><p>思路：我想到的和题解差不多，主要思路都是删除或者找到局部峰值从而得到全局最优，难点在于如何处理两边端点处的峰值。我采用的是分类举例逐渐删除连续点，随想录的方法简洁很多，统计峰值，其实和我一开始设计的循环判定类似，但是我没有处理好遍历方式，导致刚开始代码没有AC</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wiggleMaxLength</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment">#log = len(nums) - 1 #下标</span><br>        <span class="hljs-built_in">print</span>(log)<br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># if len(nums) == 1:</span><br>        <span class="hljs-comment">#     return 1</span><br>        <span class="hljs-comment"># if len(nums) &lt;3 and len(nums) &gt; 1:</span><br>        <span class="hljs-comment">#     if nums[0] == nums[1]:</span><br>        <span class="hljs-comment">#         return 1</span><br>        <span class="hljs-comment">#     elif nums[0] != nums[1]:</span><br>        <span class="hljs-comment">#         return 2</span><br>        <span class="hljs-comment"># if len(nums) &gt;=3:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] == nums[<span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> nums[<span class="hljs-number">0</span>] != nums[<span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>        <span class="hljs-keyword">while</span> i &lt;= <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">3</span> :<br>            <span class="hljs-comment">#遍</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">2</span>:<br>                <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] == nums[<span class="hljs-number">1</span>]:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>                <span class="hljs-keyword">elif</span> nums[<span class="hljs-number">0</span>] != nums[<span class="hljs-number">1</span>]:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>            <span class="hljs-built_in">print</span>(nums)<br>            <span class="hljs-built_in">print</span>(i)<br>            <span class="hljs-keyword">if</span> nums[i] &lt;= nums[i+<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> nums[i+<span class="hljs-number">1</span>] &lt;= nums[i+<span class="hljs-number">2</span>]:<br>                <span class="hljs-keyword">del</span> nums[i+<span class="hljs-number">1</span>]<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;删除后&quot;</span>+<span class="hljs-built_in">str</span>(nums))<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">2</span>:<br>                    <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] == nums[<span class="hljs-number">1</span>]:<br>                        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">elif</span> nums[<span class="hljs-number">0</span>] != nums[<span class="hljs-number">1</span>]:<br>                        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>            <span class="hljs-keyword">elif</span> nums[i] &gt;= nums[i+<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> nums[i+<span class="hljs-number">1</span>] &gt;= nums[i+<span class="hljs-number">2</span>]:<br>                <span class="hljs-keyword">del</span> nums[i+<span class="hljs-number">1</span>]<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;删除后&quot;</span>+<span class="hljs-built_in">str</span>(nums))<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">2</span>:<br>                    <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] == nums[<span class="hljs-number">1</span>]:<br>                        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">elif</span> nums[<span class="hljs-number">0</span>] != nums[<span class="hljs-number">1</span>]:<br>                        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>            <span class="hljs-keyword">else</span>:<br>                i += <span class="hljs-number">1</span><br>        <span class="hljs-comment">#print(nums)</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wiggleMaxLength</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt;= <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums)<br>        i = <span class="hljs-number">0</span><br>        res = <span class="hljs-number">1</span> <span class="hljs-comment">#默认左边有一个</span><br>        predif = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>: <span class="hljs-comment">#初始化变量一般都要放在循环外，不然每次循环都会初始化一次</span><br>            curdif = nums[i + <span class="hljs-number">1</span>] - nums[i]<br>            i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> (curdif &gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> predif &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> (predif &gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> curdif &lt; <span class="hljs-number">0</span>):<br>                res += <span class="hljs-number">1</span><br>                predif = curdif<br>        <span class="hljs-keyword">return</span> res <br></code></pre></td></tr></table></figure>
<h4 id="最大子序列和"><a href="#最大子序列和" class="headerlink" title="最大子序列和"></a>最大子序列和</h4><p>其实是个DP问题，但可以发现局部贪心无返利，由此可以推出全局最优解</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxSubArray</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment">#直接逐个遍历的暴力解法也很方便，但局部还可以继续优化，所以可以用贪心算法，根据题意，当我的子数组合出现负值时，说明前面的子序已经不能用了，加了只会拖累总和，所以从下一个开始继续重新计数</span><br>        count = <span class="hljs-number">0</span> <span class="hljs-comment">#计数器</span><br>        i = <span class="hljs-number">0</span> <span class="hljs-comment">#数组遍历标志位</span><br>        <span class="hljs-built_in">max</span> = -<span class="hljs-number">10</span>^<span class="hljs-number">4</span><br>        <span class="hljs-keyword">while</span> i &lt;= <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>:<br>            pro = count<br>            count += nums[i]<br>            <span class="hljs-keyword">if</span> count &gt; <span class="hljs-built_in">max</span>:<br>                <span class="hljs-built_in">max</span> = count<br>            <span class="hljs-keyword">if</span> count &lt; <span class="hljs-number">0</span>:<br>                count = <span class="hljs-number">0</span><br>                pro = <span class="hljs-number">0</span><br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span><br></code></pre></td></tr></table></figure>
<h4 id="经典问题-股票买卖获得的最大收益"><a href="#经典问题-股票买卖获得的最大收益" class="headerlink" title="经典问题:股票买卖获得的最大收益"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock">经典问题:股票买卖获得的最大收益</a></h4><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。<br>贪心：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfit</span>(<span class="hljs-params">self, prices: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        cur = <span class="hljs-number">99999999999999999</span><br>                maxgot = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">for</span> curprice <span class="hljs-keyword">in</span> prices:<br>                    got = <span class="hljs-number">0</span><br>                    <span class="hljs-keyword">if</span> curprice &lt; cur:<br>                        cur = curprice<br>                    <span class="hljs-keyword">else</span>:<br>                        got = curprice - cur<br>                    <span class="hljs-keyword">if</span> got &gt; maxgot:<br>                        maxgot = got<br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-keyword">pass</span><br>                <span class="hljs-keyword">return</span> maxgot<br></code></pre></td></tr></table></figure>
<p>动态规划：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfit</span>(<span class="hljs-params">self, prices: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        n = <span class="hljs-built_in">len</span>(prices)<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 边界条件</span><br>        dp = [<span class="hljs-number">0</span>] * n<br>        minprice = prices[<span class="hljs-number">0</span>] <br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            minprice = <span class="hljs-built_in">min</span>(minprice, prices[i])<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>], prices[i] - minprice)<br><br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>
<h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><p><img src="https://img-blog.csdnimg.cn/20210219192050666.png"><br>回溯其实是不断进行递归搜索的for循环，就好像你想把10个数进行两两的组合，就要用双层for循环遍历<br>那100个数进行十十组合了，全部写出来不现实，所以要采用回溯算法在每传入一个递归参数（+1）时可以顺利地完成所有的组合</p>
<h4 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h4><p>高维组合问题是经典的回溯算法应用问题<br><img src="https://img-blog.csdnimg.cn/20201123195242899.png"></p>
<h4 id="分割回文串问题"><a href="#分割回文串问题" class="headerlink" title="分割回文串问题"></a>分割回文串问题</h4><h4 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h4><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><img data-fancybox="gallery" data-sizes="auto" data-src="https://code-thinking.cdn.bcebos.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%80%BB%E7%BB%93%E5%A4%A7%E7%BA%B21.jpg" alt="动态规划" class="lazyload"></p>
<h4 id="什么是DP（动态规划）"><a href="#什么是DP（动态规划）" class="headerlink" title="什么是DP（动态规划）"></a>什么是DP（动态规划）</h4><p>动态规划中每一个状态一定是由上一个状态推导出来的，这一点区分于贪心算法，贪心没有状态推倒关系，而是模拟局部最优解获得全局最优解（孤儿求强）。例如背包问题，动态规划dp[j]是由dp[j-weight]推倒就最直而来，贪心则是每次都拿最大的就可以了<br><strong>应用场合:</strong> 动态规划又称之为DP，如果某一问题有很多重叠子问题，使用动态规划的方法是最有效的</p>
<h4 id="解题步骤（动规五部曲）"><a href="#解题步骤（动规五部曲）" class="headerlink" title="解题步骤（动规五部曲）"></a>解题步骤（动规五部曲）</h4><p>关注问题：DP数组下标的含义，递推公式，DP数组如何初始化，遍历顺序</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
<h4 id="DP如何debug"><a href="#DP如何debug" class="headerlink" title="DP如何debug"></a>DP如何debug</h4><ol>
<li>找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！</li>
<li>做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果。然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。</li>
<li>如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。</li>
<li>这样才是一个完整的思考过程，而不是一旦代码出问题，就毫无头绪的东改改西改改，最后过不了，或者说是稀里糊涂的过了。</li>
</ol>
<h4 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h4><h4 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h4><h4 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h4><h4 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h4><ul>
<li>找最长子序列<h3 id="深度优先搜索算法DFS"><a href="#深度优先搜索算法DFS" class="headerlink" title="深度优先搜索算法DFS"></a>深度优先搜索算法DFS</h3>深度优先搜索：<br>深度优先搜索是搜索的一种方式，根本是使用堆栈和递归操作，将多节点的某分支/沿某一方向搜索到底的算法。<br>图像渲染问题<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">floodFill</span>(<span class="hljs-params">self, image, sr, sc, newColor</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type image: List[List[int]]</span><br><span class="hljs-string">        :type sr: int</span><br><span class="hljs-string">        :type sc: int</span><br><span class="hljs-string">        :type newColor: int</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        R, C = <span class="hljs-built_in">len</span>(image), <span class="hljs-built_in">len</span>(image[<span class="hljs-number">0</span>])<span class="hljs-comment">#获取图像的长和宽</span><br>        color = image[sr][sc] <span class="hljs-comment">#初始值颜色</span><br>        <span class="hljs-keyword">if</span> color == newColor: <span class="hljs-keyword">return</span> image<br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">r, c</span>):</span><br>            <span class="hljs-keyword">if</span> image[r][c] == color: <span class="hljs-comment">#如果和初始值一样，渲染</span><br>                image[r][c] = newColor<br>                <span class="hljs-keyword">if</span> r &gt;= <span class="hljs-number">1</span>:  <span class="hljs-comment">#然后看上下左右是否合适进行递归搜索</span><br>                    dfs(r-<span class="hljs-number">1</span>, c)<br>                <span class="hljs-keyword">if</span> r+<span class="hljs-number">1</span> &lt; R:<br>                    dfs(r+<span class="hljs-number">1</span>, c)<br>                <span class="hljs-keyword">if</span> c &gt;= <span class="hljs-number">1</span>:<br>                    dfs(r, c-<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">if</span> c+<span class="hljs-number">1</span> &lt; C:<br>                    dfs(r,c+<span class="hljs-number">1</span>)<br>        dfs(sr, sc) <span class="hljs-comment">#引用递归</span><br>        <span class="hljs-keyword">return</span> image<br></code></pre></td></tr></table></figure>
<h3 id="广度优先搜索算法BFS"><a href="#广度优先搜索算法BFS" class="headerlink" title="广度优先搜索算法BFS"></a>广度优先搜索算法BFS</h3>广度优先搜索适合搜索离初始点较近距离的目标值，因为它是多路共同发力，层层递进地去寻找目标值<br>图像渲染问题<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">floodFill</span>(<span class="hljs-params">self, image: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], sr: <span class="hljs-built_in">int</span>, sc: <span class="hljs-built_in">int</span>, newColor: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:</span><br>        currColor = image[sr][sc]<br>        <span class="hljs-keyword">if</span> currColor == newColor:<br>            <span class="hljs-keyword">return</span> image<br>        <br>        n, m = <span class="hljs-built_in">len</span>(image), <span class="hljs-built_in">len</span>(image[<span class="hljs-number">0</span>])<br>        que = collections.deque([(sr, sc)])<br>        image[sr][sc] = newColor<br>        <span class="hljs-keyword">while</span> que:<br>            x, y = que.popleft()<br>            <span class="hljs-keyword">for</span> mx, my <span class="hljs-keyword">in</span> [(x - <span class="hljs-number">1</span>, y), (x + <span class="hljs-number">1</span>, y), (x, y - <span class="hljs-number">1</span>), (x, y + <span class="hljs-number">1</span>)]:<br>                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= mx &lt; n <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= my &lt; m <span class="hljs-keyword">and</span> image[mx][my] == currColor:<br>                    que.append((mx, my))<br>                    image[mx][my] = newColor<br>        <br>        <span class="hljs-keyword">return</span> image<br></code></pre></td></tr></table></figure>
<h3 id="刷题总结，代码随想录就是一个刷题套路集合"><a href="#刷题总结，代码随想录就是一个刷题套路集合" class="headerlink" title="刷题总结，代码随想录就是一个刷题套路集合"></a>刷题总结，代码随想录就是一个刷题套路集合</h3></li>
</ul>
<ol>
<li>跟着代码随想录刷题，不知不觉这篇日志就成了万字长文，几个月的刷题，收获不多不少，但对提升代码的理解和解决问题的思维很有帮助~感谢Carl师兄！（为此特意在京东补购了一本方便以后随时翻阅）</li>
<li>这次可以说是从零基础开始的刷题，从数据结构到算法应用，复习了曾经学过的数组、链表以及字符串，新了解哈希表、二叉树这两种数据结构，新学习了贪心，回溯，动规等很有意义的解题思路和方法，当然，在解决各个问题的过程中还有很多的精华思路（比如双指针操作链表，操作链表的元素，推导判断链表是否有环，对数组进行二分查找，操作数组，使用哈希表进行快速查询，以及二叉树的遍历中学会的递归和迭代）</li>
<li>套路总结<table>
<thead>
<tr>
<th>套路</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>递归三部曲</td>
<td>1.返回值参数 2.递归终止条件 3.单层逻辑</td>
</tr>
<tr>
<td>回溯三部曲</td>
<td>1.返回值参数 2.递归终止条件 3.单层逻辑</td>
</tr>
<tr>
<td>动规五部曲</td>
<td>1.确定dp数组以及含义 2.确定递推公式 3.dp数组如何初始化 4.确定遍历顺序 5.举例推导一下</td>
</tr>
</tbody></table>
</li>
</ol>
<p><strong>后面，我会开始边投递简历边开始在牛客网熟悉ACM模式解题，顺便复习曾经学过的套路</strong></p>
<h2 id="以后的纯刷题部分"><a href="#以后的纯刷题部分" class="headerlink" title="以后的纯刷题部分"></a>以后的纯刷题部分</h2><ol start="0">
<li>ACM模式python输入输出方法OJ<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#单个输入</span><br>n = <span class="hljs-built_in">input</span>()<br><span class="hljs-comment">#map接收单行多个</span><br>nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split()))<br><span class="hljs-comment">#分收两个</span><br>x, y = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split().split())<br><span class="hljs-comment">#接收多行</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split()))<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-keyword">break</span><br><span class="hljs-comment"># 循环输入</span><br>n, x = [<span class="hljs-built_in">int</span>(s) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()]<br><span class="hljs-comment"># 序列输入</span><br>score = [<span class="hljs-built_in">int</span>(s) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()]<br><br></code></pre></td></tr></table></figure></li>
<li>拿到这道题直接就想到了双循环遍历然后计数，是很显然的方法，但问题就是复杂度太高了，吃满数组内存运行起来又是N的平方，数据量一大就是指数型爆炸的运算量，其实最好的方法有排序法和哈希表法！<ul>
<li>排序测邻：优势，排序的复杂度只有logN，要比双循环好，而且有sorted（）、set（）这种直接处理序列的API，实现起来很方便。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == nums[i + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li>哈希表：对于数组中每个元素，我们将它插入到哈希表中。如果插入一个元素时发现该元素已经存在于哈希表中，则说明存在重复的元素。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-keyword">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x: nums) &#123;<br>            <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(x) != s.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            s.<span class="hljs-built_in">insert</span>(x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>递归思想解决斐波那数列问题<ul>
<li>为什么想到递归方法，因为递推过程每一层的操作是一样的，解决的问题具备重复的单层逻辑就可以采用递归策略，然后再设计出相应的返回值、变量和终止条件<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span>(<span class="hljs-params">self, n</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :type n: int</span><br><span class="hljs-string">    :rtype: int</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    dp = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>    i = <span class="hljs-number">2</span><br>    self.diguifa(dp,i,n) <span class="hljs-comment">#类内的自调用和相互调用一般都需要self作为实例参数</span><br>    <span class="hljs-comment">#print(dp)</span><br>    <span class="hljs-keyword">return</span> dp[n]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">diguifa</span>(<span class="hljs-params">self,dp,i,n</span>):</span><br>    <span class="hljs-keyword">if</span> i &lt;= n:<br>        temp = dp[i-<span class="hljs-number">1</span>] +dp[i-<span class="hljs-number">2</span>]<br>        <span class="hljs-comment">#print(temp)</span><br>        dp.append(temp)<br>        self.diguifa(dp,i+<span class="hljs-number">1</span>,n)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>移动零问题<ul>
<li>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。<br>请注意 必须在不复制数组的情况下原地对数组进行操作。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">moveZeroes</span>(<span class="hljs-params">self, nums</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :type nums: List[int]</span><br><span class="hljs-string">    :rtype: None Do not return anything, modify nums in-place instead.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment">#应该是很经典的双指针，前一个指针遍历，后一个指针用来把0往后推（原始做法）,</span><br>    <span class="hljs-comment">#还可以用删除计数，最后再nums末尾补0的方法，但会改变数组的尺寸，导致不好遍历，得想点办法:换个遍历方式不就行了！for range是枚举式遍历，不好控制进度，那就使用带条件的循环遍历</span><br>    <span class="hljs-comment">#left, right = 0, len(nums)-1</span><br>    count = <span class="hljs-number">0</span><br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> i &lt;= <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">print</span>(i)<br>        <span class="hljs-keyword">if</span> nums[i] == <span class="hljs-number">0</span>:<br>            nums.pop(i)<br>            count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            i += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(nums)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(count):<br>        nums.append(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> nums<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>两数之和/n数之和问题拓展： <ul>
<li>输入有序数组问题：给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 &lt;= index1 &lt; index2 &lt;= numbers.length 。以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。你所设计的解决方案必须只使用常量级的额外空间。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span>(<span class="hljs-params">self, numbers, target</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :type numbers: List[int]</span><br><span class="hljs-string">    :type target: int</span><br><span class="hljs-string">    :rtype: List[int]</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment">#二分法的要求是数组有序且无重复，题意好像不满足无重复</span><br>    <span class="hljs-comment">#与其两次循环遍历，不如一次遍历，一次二分查找降低复杂度</span><br>    <span class="hljs-comment">#循环到一个数，拿target减去他，在后面的数里进行二分查找（因为如果是前面的，那肯定已经找出来了），最后组合数组</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(numbers)):<br>        tar2 = target - numbers[i]<br>        left, right = i, <span class="hljs-built_in">len</span>(numbers)-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> left &lt;= right:<br>            mid = (left + right) / <span class="hljs-number">2</span><br>            <span class="hljs-comment">#print(mid)</span><br>            <span class="hljs-keyword">if</span> numbers[mid] &lt; tar2:<br>                <span class="hljs-comment">#目标在右，左指针动</span><br>                left = mid + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> numbers[mid] == tar2:<br>                <span class="hljs-comment">#找到了，返回</span><br>                <span class="hljs-keyword">if</span> mid == i: <span class="hljs-comment">#判定同时出现两个相同的数后使用到了同一个下标,如果一开始就让left+1的话可以避免这个问题（官方解答）</span><br>                    mid = i + <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">return</span> [i+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">return</span> [i+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>] <span class="hljs-comment">#示例比下标索引多1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment">#目标在左</span><br>                right = mid - <span class="hljs-number">1</span>       <br>    <span class="hljs-keyword">return</span> [-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>链表中间节点问题(一次AC)<ul>
<li>给定一个头结点为 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">middleNode</span>(<span class="hljs-params">self, head</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type head: ListNode</span><br><span class="hljs-string">        :rtype: ListNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 直接写？不对，应该用一个指针与另外一个指针始终保持两倍的距离关系</span><br>        cur = head<br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">togo</span>(<span class="hljs-params">step</span>):</span><br>            pro = head<br>            <span class="hljs-keyword">while</span> step != <span class="hljs-number">0</span>:<br>                pro = pro.<span class="hljs-built_in">next</span><br>                step -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> pro<br>        <span class="hljs-keyword">while</span> cur != <span class="hljs-literal">None</span>:<br>            cur = cur.<span class="hljs-built_in">next</span><br>            count += <span class="hljs-number">1</span> <br>        <span class="hljs-comment">#count % 2 == 0:</span><br>        <span class="hljs-comment">#是偶数，输出右边节点</span><br>        step = <span class="hljs-built_in">int</span>(count / <span class="hljs-number">2</span>)<br>        pro = togo(step)<br>        <span class="hljs-keyword">return</span> pro<br>        <span class="hljs-comment"># else:</span><br>        <span class="hljs-comment">#     step = count / 2</span><br>        <span class="hljs-comment">#     pro = togo(step)</span><br>        <span class="hljs-comment">#     return pro</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>旋转序列求最大子序问题(DP法)<ul>
<li>小美请小团吃回转寿司。转盘上有N盘寿司围成一圈，第1盘与第2盘相邻，第2盘与第3盘相邻，…，第N-1盘与第N盘相邻，第N盘与第1盘相邻。小团认为第i盘寿司的美味值为A[i]（可能是负值，如果小团讨厌这盘寿司）。现在，小团要在转盘上选出连续的若干盘寿司，使得这些寿司的美味值之和最大（允许不选任何寿司，此时美味值总和为0）。</li>
<li>输入：第一行输入一个整数T（1&lt;=T&lt;=10），表示数据组数。每组数据占两行，第一行输入一个整数N（1&lt;=N&lt;=10^5）；第二行输入N个由空格隔开的整数，表示A[1]到A[N]（-10^4&lt;=A[i]&lt;=10^4）。</li>
<li>输出：每组数据输出占一行，输出一个整数，表示连续若干盘寿司的美味值之和的最大值。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findMaxSum</span>(<span class="hljs-params">N,score</span>):</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">动态规划的想法：</span><br><span class="hljs-string">pre[i]储存以第i个数结尾的连续数组的最大和，这样的连续数组只有两种可能</span><br><span class="hljs-string">第一种，这个数组只有一个数，即第i个数</span><br><span class="hljs-string">第二种，这个数组多于一个数，那么就是第i个数加以第i-1个数结尾的连续数组的最大和pre[i-1]</span><br><span class="hljs-string">取这两个值的最大值</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>pre = [<span class="hljs-number">0</span>] <span class="hljs-comment">#为什么提前设0，这里是初始化pre[i]，让pre在i+1的地方append以i为结尾的最大值</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N):<br>    maxSum = <span class="hljs-built_in">max</span>(score[i],score[i]+pre[i])<br>    pre.append(maxSum) <br><span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(pre)<br> <br> <br>T = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">while</span> T:<br>    T = T-<span class="hljs-number">1</span><br>    N = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    score = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>    maximum = findMaxSum(N,score)<br>    minimum = findMaxSum(N,[-i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> score])<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span>(score)+minimum&gt;maximum:<br>        maximum = <span class="hljs-built_in">sum</span>(score)+minimum<br>    <span class="hljs-built_in">print</span>(maximum)<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>无向图和有向图<ul>
<li>小团找到一颗有n个节点的苹果树，以1号节点为根，且每个节点都有一个苹果，苹果都有一个颜色，但是这棵树被施加了咒术，这使得小团只能从某一个节点的子树中选取某一种颜色的拿。小团想要拿到数量最多的那种颜色的所有苹果，请帮帮她。每次她会指定一个节点t，如果小团只能从节点t的子树中选取某一种颜色的苹果，选取什么颜色能拿到最多的苹果？如果有多种颜色都可以拿同样多的苹果，输出颜色编号最小的那个对应的编号。节点x的子树定义为所有将x当作祖先的节点，x也视为x的子树的一部分。</li>
<li>题目中只告诉我们1为根节点，因此在输入两个有边相连的节点时，我们并不知道哪个是父节点哪个是子节点，需要先构建无向图的邻接表。然后从根节点1开始，自顶向下删去子节点指向父节点的关系，将无向图修改为有向图。<br>在每次query的过程中，利用bfs求得每个节点 t 的子树对应的所有节点，然后对节点颜色进行计数，输出出现最多且编号最小的颜色即可。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bfs</span>(<span class="hljs-params">root, tree</span>):</span><br>    queue = Queue()<br>    queue.put(root)<br>    children = [root]<br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> queue.empty():<br>        cur = queue.get()<br>        <span class="hljs-keyword">if</span> cur <span class="hljs-keyword">in</span> tree:<br>            <span class="hljs-comment"># 还没到叶子节点</span><br>            <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> tree[cur]:<br>                queue.put(child)<br>                children.append(child)<br>    <span class="hljs-keyword">return</span> children<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">modify</span>(<span class="hljs-params">root</span>):</span><br>    <span class="hljs-keyword">if</span> tree[root]:<br>        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> tree[root]:<br>            <span class="hljs-comment"># 将子节点指向父节点的关系删除</span><br>            tree[child].remove(root)<br>            modify(child)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    tree = defaultdict(<span class="hljs-keyword">lambda</span>: [])<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):<br>        x, y = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().strip().split())<br>        tree[x].append(y)<br>        tree[y].append(x)<br>    <span class="hljs-comment"># 根据拓扑关系，将树改为有向图</span><br>    modify(<span class="hljs-number">1</span>)<br>    colors = <span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().strip().split()))<br>    q = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(q):<br>        t = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>        <span class="hljs-comment"># bfs获得节点t的所有子节点(包括自己)</span><br>        children = bfs(t, tree)<br>        <span class="hljs-comment"># 颜色计数器</span><br>        counter = defaultdict(<span class="hljs-keyword">lambda</span>: <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> children:<br>            counter[colors[child - <span class="hljs-number">1</span>]] += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 输出数量最多的颜色</span><br>        maxColor = <span class="hljs-number">5001</span><br>        maxCount = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> color <span class="hljs-keyword">in</span> counter:<br>            <span class="hljs-keyword">if</span> maxCount &lt; counter[color]:<br>                maxCount = counter[color]<br>                maxColor = color<br>            <span class="hljs-keyword">elif</span> maxCount == counter[color]:<br>                maxColor = <span class="hljs-built_in">min</span>(color, maxColor)<br>        <span class="hljs-built_in">print</span>(maxColor)<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>神秘代码问题<ul>
<li>对于一个长度为n的字符串s，其对应的加密字符串t的第一个字符是s中的第n/2个字符（向上取整），而t中的第二个到第n个字符则刚好对应s删去第n/2个字符（向上取整）后所得字符串的加密字符串。这个规则也可以用如下流程描述：将t初始化为一个空串，不断从s中取出第n / 2个字符（向上取整），并将其拼到t的后面，当s为空时，t即是所求的加密字符串。设计命令行工具加密解密。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>():</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">secret</span>(<span class="hljs-params">self, string, num, t</span>):</span> <span class="hljs-comment">#选择加密解密模式</span><br>        <span class="hljs-keyword">if</span> t == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> self.type1(string, num)<br>        <span class="hljs-keyword">if</span> t == <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> self.type2(string, num)<br>    <span class="hljs-comment">#取字符方法，也有直接暴力删除的方式</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">type1</span>(<span class="hljs-params">self, strings, nums</span>):</span>  <span class="hljs-comment">#加密</span><br>        strings = <span class="hljs-string">&#x27;0&#x27;</span> + strings <span class="hljs-comment">#补首0移位,让下标数字自然对应字符串位数</span><br>        res = []<br>        temp = <span class="hljs-number">0</span><br>        mininum = <span class="hljs-number">1000000000</span><br>        <span class="hljs-keyword">while</span> temp &lt; nums:<br>            a = math.ceil((nums - temp)/<span class="hljs-number">2</span>) <span class="hljs-comment">#求第n/2个字符（向上取整）位置，但是要取的要么在左，要么在右，所以要加入如下判断</span><br>            <span class="hljs-keyword">if</span> a &lt; mininum:<br>                res.append(strings[a]) <span class="hljs-comment">#拼接到a后</span><br>            <span class="hljs-keyword">else</span>:<br>                res.append(strings[a+temp])<span class="hljs-comment">#当a等于min，代表要append字符串后半段了</span><br>            mininum = <span class="hljs-built_in">min</span>(a, mininum)<span class="hljs-comment"># 取最小字符位置</span><br>            temp += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">type2</span>(<span class="hljs-params">self, strings, nums</span>):</span><br>        strings = <span class="hljs-string">&#x27;0&#x27;</span> + strings<br>        res = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nums+<span class="hljs-number">1</span>)]<br>        temp = <span class="hljs-number">0</span><br>        index = <span class="hljs-number">1</span><br>        mininum = <span class="hljs-number">1000000000</span><br>        <span class="hljs-keyword">while</span> temp &lt; nums:<br>            a = math.ceil((nums - temp)/<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">if</span> a &lt; mininum:<br>                res[a] = strings[index]<br>            <span class="hljs-keyword">else</span>:<br>                res[a + temp] = strings[index]<br>            mininum = <span class="hljs-built_in">min</span>(a, mininum)<br>            temp += <span class="hljs-number">1</span><br>            index += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">del</span> res[<span class="hljs-number">0</span>] <span class="hljs-comment">#去0</span><br>        <span class="hljs-keyword">return</span> res<br><br><span class="hljs-comment">#输入输出样例</span><br>a = Solution()<br>string = <span class="hljs-string">&#x27;hhhaaa&#x27;</span><br>num = <span class="hljs-number">6</span><br>t = <span class="hljs-number">2</span><br>r = a.secret(string, num, t)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; &quot;</span>.join(r))<br><span class="hljs-comment">#输出“ahhhaa”</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>分鸡蛋的教训：鸡蛋一般都不会只在一个篮子里<ul>
<li>京东笔试分鸡蛋问题，一个大妈手里有x的鸡蛋，每次要么去鸡窝里拿一个，要么在手里能分三份的情况下分两份给别人，问什么时候可以手里拥有y个鸡蛋<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python">T = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> T &gt; <span class="hljs-number">0</span>:<br>    T -= <span class="hljs-number">1</span><br>    x, y = <span class="hljs-number">25</span>, <span class="hljs-number">9</span><br>    <span class="hljs-comment">#print(x,y)</span><br>    count = <span class="hljs-number">0</span><br>    temp = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> x != y:<br>            near = <span class="hljs-number">3</span> * (<span class="hljs-built_in">int</span>(x / <span class="hljs-number">3</span>) + <span class="hljs-number">1</span>) <span class="hljs-comment">#找最近的</span><br>            <span class="hljs-comment">#print(near)</span><br>            std = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(x,temp))<br>            <span class="hljs-built_in">print</span>(std)<br>            <span class="hljs-keyword">if</span> y <span class="hljs-keyword">in</span> std:<br>                count += y-x<br>                x = y<br>            <span class="hljs-keyword">elif</span> x % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>:<br>                temp = x<br>                x = <span class="hljs-built_in">int</span>(x / <span class="hljs-number">3</span>)<br>                count += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                count += near - x<br>                x = near<br>            <span class="hljs-built_in">print</span>(x)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">int</span>(count))<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>LRU缓存机制<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lru-cache/">leetcode</a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#哈希表+双向链表</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, key=<span class="hljs-literal">None</span>, value=<span class="hljs-literal">None</span></span>):</span><br>        self.key = key<br>        self.value = value<br>        self.prev = <span class="hljs-literal">None</span><br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, capacity: <span class="hljs-built_in">int</span></span>):</span><br>        self.capacity = capacity<br>        self.hashmap = &#123;&#125;<br>        <span class="hljs-comment"># 新建两个节点 head 和 tail</span><br>        self.head = ListNode()<br>        self.tail = ListNode()<br>        <span class="hljs-comment"># 初始化链表为 head &lt;-&gt; tail</span><br>        self.head.<span class="hljs-built_in">next</span> = self.tail<br>        self.tail.prev = self.head<br><br>    <span class="hljs-comment"># 因为get与put操作都可能需要将双向链表中的某个节点移到头部(变成最新访问的)，所以定义一个移动方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">move_node_to_header</span>(<span class="hljs-params">self, key</span>):</span><br>            <span class="hljs-comment"># 先将哈希表key指向的节点拎出来，为了简洁起名node</span><br>            <span class="hljs-comment">#      hashmap[key]                               hashmap[key]</span><br>            <span class="hljs-comment">#           |                                          |</span><br>            <span class="hljs-comment">#           V              --&gt;                         V</span><br>            <span class="hljs-comment"># prev &lt;-&gt; node &lt;-&gt; next         pre &lt;-&gt; next   ...   node</span><br>            node = self.hashmap[key]<br>            node.prev.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span><br>            node.<span class="hljs-built_in">next</span>.prev = node.prev<br>            <span class="hljs-comment"># 之后将node插入到头部节点前</span><br>            <span class="hljs-comment">#                   hashmap[key]                     hashmap[key]</span><br>            <span class="hljs-comment">#                       |                                 |</span><br>            <span class="hljs-comment">#                       V        --&gt;                      V</span><br>            <span class="hljs-comment"># header &lt;-&gt; next  ... node                   header &lt;-&gt; node &lt;-&gt; next</span><br>            node.prev = self.head<br>            node.<span class="hljs-built_in">next</span> = self.head.<span class="hljs-built_in">next</span><br>            self.head.<span class="hljs-built_in">next</span>.prev = node<br>            self.head.<span class="hljs-built_in">next</span> = node<br>            <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_node_to_header</span>(<span class="hljs-params">self, key,value</span>):</span><br>        new = ListNode(key, value)<br>        self.hashmap[key] = new<br>        new.prev = self.head<br>        new.<span class="hljs-built_in">next</span> = self.head.<span class="hljs-built_in">next</span><br>        self.head.<span class="hljs-built_in">next</span>.prev = new<br>        self.head.<span class="hljs-built_in">next</span> = new<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop_tail</span>(<span class="hljs-params">self</span>):</span><br>        last_node = self.tail.prev<br>        <span class="hljs-comment"># 去掉链表尾部的节点在哈希表的对应项</span><br>        self.hashmap.pop(last_node.key)<br>        <span class="hljs-comment"># 去掉最久没有被访问过的节点，即尾部Tail之前的一个节点</span><br>        last_node.prev.<span class="hljs-built_in">next</span> = self.tail<br>        self.tail.prev = last_node.prev<br>        <span class="hljs-keyword">return</span> last_node<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> self.hashmap:<br>            <span class="hljs-comment"># 如果已经在链表中了久把它移到头部（变成最新访问的）</span><br>            self.move_node_to_header(key)<br>        res = self.hashmap.get(key, -<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> res == -<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> res<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> res.value<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">put</span>(<span class="hljs-params">self, key: <span class="hljs-built_in">int</span>, value: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> self.hashmap:<br>            <span class="hljs-comment"># 如果key本身已经在哈希表中了就不需要在链表中加入新的节点</span><br>            <span class="hljs-comment"># 但是需要更新字典该值对应节点的value</span><br>            self.hashmap[key].value = value<br>            <span class="hljs-comment"># 之后将该节点移到链表头部</span><br>            self.move_node_to_header(key)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.hashmap) &gt;= self.capacity:<br>            <span class="hljs-comment"># 若cache容量已满，删除cache中最不常用的节点 </span><br>                self.pop_tail()<br>            self.add_node_to_header(key,value)<br></code></pre></td></tr></table></figure></li>
<li>摸鱼问题：<br>一个打工仔，一开始工作效率是1，每分钟后增加1，最高是M，M后还能干T分钟，不然得歇息10分钟重新从1开始发力，或者他中途任意时刻都能选择摸鱼5分钟，之后再从摸鱼前一半的搬砖速度开始干起，直到干完任务量N。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#摸鱼问题</span><br>N,M,T = [<span class="hljs-built_in">int</span>(s) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()]<br><span class="hljs-comment">#找时间最优问题，一种是干到M后强制休息10分钟重新从1开始，一种是中途任何时候选择摸鱼5分钟，效率仅为之前的一半</span><br>speed = <span class="hljs-number">1</span> <span class="hljs-comment">#初始工作效率</span><br><span class="hljs-comment">#贪心，因为摸鱼等于5分钟后从一半启动，肝满T等于从1启动，所以肝到T-1，然后摸鱼，以此循环</span><br>t = <span class="hljs-number">0</span><br>Tt = T<br><span class="hljs-keyword">while</span> N &gt; <span class="hljs-number">0</span>:<br>    <span class="hljs-keyword">if</span> speed == M:<br>        Tt -= <span class="hljs-number">1</span><br>        N -= speed<br>        <span class="hljs-keyword">if</span> Tt == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (N-speed)&gt;<span class="hljs-number">0</span>:<br>            <span class="hljs-comment">#下一步已经做不完了，可以开始摸鱼，一开始N&lt;speed可以一步做完这个情况想漏了，告诉我每次if else前是否把启动一个事件的必要条件考虑周全，不然就是某些莫名的bug</span><br>            t += <span class="hljs-number">5</span><br>            speed = <span class="hljs-built_in">int</span>(speed / <span class="hljs-number">2</span>)<br>            Tt = T<br>    <span class="hljs-keyword">else</span>:<br>        N -= speed<br>        speed += <span class="hljs-number">1</span><br>    t += <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(t)<br></code></pre></td></tr></table></figure></li>
<li>面试题：创建一个可以找最小的堆class，并在0(1)时间内返回<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.stack = []  <span class="hljs-comment"># 存放所有元素</span><br>        self.minStack = []  <span class="hljs-comment"># 存放每一次压入数据时，栈中的最小值</span><br>                            <span class="hljs-comment"># （如果压入数据的值大于栈中的最小值就不需要重复压入最小值，</span><br>                            <span class="hljs-comment"># 小于或者等于栈中最小值则需要压入）</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span>(<span class="hljs-params">self, x</span>):</span><br>        self.stack.append(x)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.minStack <span class="hljs-keyword">or</span> self.minStack[-<span class="hljs-number">1</span>] &gt;= x:<br>            self.minStack.append(x)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span>(<span class="hljs-params">self</span>):</span>  <span class="hljs-comment"># 移除栈顶元素时，判断是否移除栈中最小值</span><br>        <span class="hljs-keyword">if</span> self.minStack[-<span class="hljs-number">1</span>] == self.stack[-<span class="hljs-number">1</span>]:<br>            <span class="hljs-keyword">del</span> self.minStack[-<span class="hljs-number">1</span>]<br>        self.stack.pop()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top</span>(<span class="hljs-params">self</span>):</span>   <span class="hljs-comment">#获取栈顶元素</span><br>        <span class="hljs-keyword">return</span> self.stack[-<span class="hljs-number">1</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getMin</span>(<span class="hljs-params">self</span>):</span> <br>        out = self.minStack[-<span class="hljs-number">1</span>]<span class="hljs-comment">#获取栈中的最小值，想要O（1）时间实现，可以先存一下</span><br>        <span class="hljs-keyword">return</span> out<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">all</span>(<span class="hljs-params">self</span>):</span>  <span class="hljs-comment">#列表栈中所有的元素</span><br>        <span class="hljs-keyword">return</span> self.stack[:]<br></code></pre></td></tr></table></figure></li>
<li>美团面试：栈的压入、弹出序列<br>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）<br>思路：<br>既然是比较找的压入顺序和栈的弹出顺序，因此，我们可以借助一个辅助栈，将压入序列中的元素，依次压入栈中，每压入一个元素，都需要和弹出序列相比较，相同则出栈。以pushV[1,2,3,4,5],popV[4,5,3,2,1]为例。先将第一个元素放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环直到，压栈顺序遍历完成。<br>理论上说，这样模拟压栈出栈顺序，如果弹出序列是压入序列的一个弹出顺序，那么当弹出序列遍历完成的时候，辅助栈stack应该为空，因为都出栈了，否则，弹出序列不是当前压入序列的一个弹出顺序。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">IsPopOrder</span>(<span class="hljs-params">self, pushV, popV</span>):</span><br>        <span class="hljs-comment"># write code here</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(pushV) != <span class="hljs-built_in">len</span>(popV):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">if</span> pushV == <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> popV != <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">if</span> pushV != <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> popV == <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        stack = []    <span class="hljs-comment"># 构造辅助栈</span><br>        index = <span class="hljs-number">0</span>     <span class="hljs-comment"># 从头开始遍历popV</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(pushV)):<br>            stack.append(pushV[i])  <span class="hljs-comment"># pushV依次入栈</span><br>            <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> stack[-<span class="hljs-number">1</span>] == popV[index]:  <br>            <span class="hljs-comment"># 每一次入栈,栈顶元素都要和出栈顺序比较，直到栈空或不相等</span><br>                stack.pop()      <span class="hljs-comment"># 相等则出栈，再继续popV的下一个元素比较</span><br>                index += <span class="hljs-number">1</span>   <span class="hljs-comment"># </span><br>        <span class="hljs-keyword">if</span> stack:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure></li>
<li>两数相除：不能实用除号，完成除法的函数编写<br>位运算方法，因为某进制的移位等于乘除法，比如二进制左移一位等于加上其乘以进制的n次方<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">divide</span>(<span class="hljs-params">self, dividend, divisor</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type dividend: int</span><br><span class="hljs-string">        :type divisor: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        flag=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> (dividend&lt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> divisor&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> (dividend&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> divisor&lt;<span class="hljs-number">0</span>):flag=-<span class="hljs-number">1</span><br>        m,n=<span class="hljs-built_in">abs</span>(dividend),<span class="hljs-built_in">abs</span>(divisor)<br>        res=<span class="hljs-number">0</span><br>     <br>        <span class="hljs-keyword">while</span> m&gt;=n:<br>            p,t=<span class="hljs-number">1</span>,n<br>            <span class="hljs-keyword">while</span> m&gt;= t&lt;&lt;<span class="hljs-number">1</span>: <span class="hljs-comment">#t左移一位，</span><br>                p&lt;&lt;=<span class="hljs-number">1</span> <span class="hljs-comment">#对应p也同时左移，patch+1</span><br>                t&lt;&lt;=<span class="hljs-number">1</span><br>            res+=p<br>            m-=t<br>       <br>        res*=flag<br>        <span class="hljs-keyword">if</span> res&lt;-<span class="hljs-number">2</span>**<span class="hljs-number">31</span> <span class="hljs-keyword">or</span> res&gt;<span class="hljs-number">2</span>**<span class="hljs-number">31</span>-<span class="hljs-number">1</span>:<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>**<span class="hljs-number">31</span>-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>
纯加减法：从计数1开始，让除数不断翻倍，得到的计数也翻倍，去逼近被除数，最后得到计数就是商<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">divide</span>(<span class="hljs-params">self, dividend, divisor</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type dividend: int</span><br><span class="hljs-string">        :type divisor: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment">#官方样例bug</span><br>        <span class="hljs-keyword">if</span> dividend == -<span class="hljs-number">2147483648</span> <span class="hljs-keyword">and</span> divisor == -<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2147483647</span><br>        <span class="hljs-keyword">if</span> dividend == <span class="hljs-number">0</span>:<span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> divisor == <span class="hljs-number">1</span>:<span class="hljs-keyword">return</span> dividend<br>        <span class="hljs-keyword">if</span> divisor == -<span class="hljs-number">1</span>:<span class="hljs-keyword">return</span> -dividend<br>        a = dividend<br>        b = divisor<br>        sign = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> b &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> (a &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> b &gt; <span class="hljs-number">0</span>) :<br>            sign = -<span class="hljs-number">1</span><br>        a = <span class="hljs-built_in">abs</span>(a)<br>        b = <span class="hljs-built_in">abs</span>(b)<br>        res = self.div(a,b)<br>        <span class="hljs-keyword">return</span> res*sign<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">div</span>(<span class="hljs-params">self,a,b</span>):</span><br>        <span class="hljs-keyword">if</span> a &lt; b:<span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        count = <span class="hljs-number">1</span><br>        tb = b <span class="hljs-comment">#除数不变</span><br>        <span class="hljs-keyword">while</span> tb+tb &lt;= a:<br>            count += count<br>            tb += tb<br>        <span class="hljs-keyword">return</span> count + div(a-tb,b) <span class="hljs-comment">#递归逼近被除数，比如60除以8，第一次，tb会8+8,16+16 ,这个时候conut就1+1,2+2,最后得4，此时对应从div（60-32，8）开始递归，tb 只8+8 count就 1+1等于2 继续从div（28-16,8），此时tb只能是8，所以count = 1，统计起来1+2+4就是7，如果还要求余数就是最后的12-8=4</span><br></code></pre></td></tr></table></figure></li>
<li>9.1深信服第一题：日志分析<br>一组攻击先后包含 s w r。现有 T 份日志，每份是一个小写字母字符串，需要从每份日志里，统计有多少种可能的潜在攻击。<br>输入：正整数 T，紧接着是 T 行日志<br>输出：T 行，每个日志的潜在攻击数。需要对 1e9+7 取模</li>
</ol>
<p>解法：这题相当于查找字符串中有多少个 “swr” 子序列。用 动态规划 比较高效，否则有些大测试点估计过不了<br>考虑如下三个动态规划函数：<br>dp_s。其中 dp_s[i] 代表字符串的前 i 个字符，有多少个子序列 “s”。<br>dp_sw。其中 dp_sw[i] 代表字符串的前 i 个字符，有多少个子序列 “sw”。<br>dp_swr。其中 dp_swr[i] 代表字符串的前 i 个字符，有多少个子序列 “swr”。<br>状态转移，需要看字符串的第 i 位是什么。 比如是 ‘r’，那么它可以额外提供的 “swr” 子序列数量即为 dp_sw [i]。其余同理，因此状态转移函数总结如下：<br>如果字符串的第 i 位是 ‘s’，则 dp_s[i] = dp_s[i - 1] + 1，否则 dp_s[i] = dp_s[i - 1]<br>如果字符串的第 i 位是 ‘w’，则 dp_sw[i] = dp_sw[i - 1] + dp_s[i]，否则 dp_sw[i] = dp_sw[i - 1]<br>如果字符串的第 i 位是 ‘r’，则 dp_swr[i] = dp_swr[i - 1] + dp_sw[i]，否则 dp_swr[i] = dp_swr[i - 1]<br>注意到，每个函数只有最后一个值会被用到，因此 可以用滚动数组节省空间。<br>我只用了 s w r 三个变量表示循环中的三个函数值。最终输出 dp_swr[n] % (1e9+7) 的值即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">T = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(T):<br>    info = <span class="hljs-built_in">input</span>()<br>    s = w = r = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(info)):<br>        <span class="hljs-keyword">if</span> info[i] == <span class="hljs-string">&#x27;s&#x27;</span>:<br>            s += <span class="hljs-number">1</span>   <span class="hljs-comment"># 遍历到第i位时，s表示 dp_s[i]的值，下同</span><br>        <span class="hljs-keyword">elif</span> info[i] == <span class="hljs-string">&#x27;w&#x27;</span>:<br>            w += s<br>        <span class="hljs-keyword">elif</span> info[i] == <span class="hljs-string">&#x27;r&#x27;</span>:<br>            r += w<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">int</span>(r % (<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>)))<br></code></pre></td></tr></table></figure>
<ol start="16">
<li>第二题：深信服旅游<br>有 T 组测试数据。每组包含正整数 n，表示员工数。之后是 n 行，每行两个正整数a, b，表示一位员工方便旅游的时间段为 [a, b]。问最多可以同时让多少位员工觉得方便。<br>输入：正整数 T。之后 T 组数据，每组先输入正整数 n；然后是 n 行，每行两个正整数<br>输出：T行，每组测试数据的结果<br>备注：O(n^2)的算法可得一半分，O(nlogn)的算法可得满分</li>
</ol>
<p>对于每组数据，分别用数组A， B记下来 所有的开始时间和所有的结束时间， 并不需要考虑它们来自于哪位员工。将它们升序排列。<br>为什么不需要考虑它们来自哪个员工呢？<br>因为我们只关注每个区间的进入和退出。比如两个区间 (1,4)+(2,3)，实际上和 (1,3)+(2,4) 是没有区别的。<br>我们要做的，是给定这些区间的首尾值，判断最多有多少个区间重合。<br>遍历数组A， 每次找到 A[i]，相当于有一个区间开始。我们还要查看 这时有多少区间已经结束。因此需要在数组B中维护一个动态指针p（p表示当前有多少个区间已经结束）。如果当前p指向的结束时间小于 A[i]，说明 当前的区间已经结束，需要不断将p右移。操作完成后， p 和 i 的下标差加1即为当前区间的重合数。<br>最后，每步 中找到的区间重合数去一个最大值即为所求。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">T = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(T):   <span class="hljs-comment">#  T组测试数据</span><br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    A, B = [], []<br>    <span class="hljs-keyword">for</span> __ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):     <span class="hljs-comment"># 每组数据n个员工</span><br>        a, b = [<span class="hljs-built_in">int</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>().split()]<br>        A.append(a)<br>        B.append(b)<br>    A.sort()<br>    B.sort()<br>    p = ans = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">while</span> p &lt; n <span class="hljs-keyword">and</span> A[i] &gt; B[p]:<br>            p += <span class="hljs-number">1</span><br>        ans = <span class="hljs-built_in">max</span>(ans, i - p + <span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(ans)<br></code></pre></td></tr></table></figure>
<p>17.第三题：五进制<br>设定一种五进制，其中 o, y, e, a, s 分别代表 0, 1, 2, 3, 4。例如五进制 ya 代表十进制 8。<br>有 T 组测试数据。每组包含一个数字，或字母oyeas组成的字符串。实现进制的相互转换，并输出每个测试数据的转换结果。<br>输入：正整数 T。之后 T 行，每行一个【五进制字母串】或【十进制数】<br>输出： T 行，给定测试如果是五进制，则输出十进制数；给定测试如果是十进制，则输出五进制字符串</p>
<p>压轴题反而是最简单的，跟二进制转化没啥区别。<br>十进制转五进制，每次对5取模，得到最低位，然后将数字除以5，直到数字变为零；<br>五进制转十进制，遍历字符串。长度为 n 的字符串，第 i 位是x，则它的贡献为 x * 5 ^ (n - i - 1)。循环求和即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br>T = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(T):<br>    ipt = <span class="hljs-built_in">input</span>()<br>    <span class="hljs-keyword">if</span> ipt.isdigit():<br>        <span class="hljs-keyword">if</span> ipt == <span class="hljs-string">&#x27;0&#x27;</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;o&#x27;</span>)<br>            <span class="hljs-keyword">continue</span><br>        ans = <span class="hljs-string">&#x27;&#x27;</span><br>        ipt = <span class="hljs-built_in">int</span>(ipt)<br>        <span class="hljs-keyword">while</span> ipt &gt; <span class="hljs-number">0</span>:<br>            ans = <span class="hljs-string">&#x27;oyeas&#x27;</span>[ipt % <span class="hljs-number">5</span>] + ans<br>            ipt //= <span class="hljs-number">5</span><br>        <span class="hljs-built_in">print</span>(ans)<br>    <span class="hljs-keyword">else</span>:<br>        ans = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(ipt)):<br>            ans += <span class="hljs-string">&#x27;oyeas&#x27;</span>.index(ipt[i]) * math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">5</span>, <span class="hljs-built_in">len</span>(ipt) - i - <span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">int</span>(ans))<br></code></pre></td></tr></table></figure>
  </article>

  
      
    <div class="nexmoe-post-copyright">
        <strong>本文作者：</strong>Natu Matu<br>
        <strong>本文链接：</strong><a href="https://631212502.github.io/2021/12/12/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/" title="https:&#x2F;&#x2F;631212502.github.io&#x2F;2021&#x2F;12&#x2F;12&#x2F;%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93&#x2F;" target="_blank" rel="noopener">https:&#x2F;&#x2F;631212502.github.io&#x2F;2021&#x2F;12&#x2F;12&#x2F;%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93&#x2F;</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>


  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
    
    
        <a class="nexmoefont icon-tag-fill -none-link" href="/tags/Coding/" rel="tag">Coding</a>
    
</div>

  
      <div class="nexmoe-post-footer">
          <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: 'cdc194d30f71cf392fdd',
        clientSecret: 'b27b4f1ec813cb7eaa115ab184569422b663176a',
        id: window.location.pathname,
        repo: '631212502.github.io',
        owner: '631212502',
        admin: '631212502'
    })
    gitalk.render('gitalk')
</script>
</section>
      </div>
  
</div>
                <div class="nexmoe-post-right">
                <div class="nexmoe-fixed">
                    <div class="nexmoe-tool"> 
                        
                            
                            
                                <button class="mdui-fab catalog" style="overflow:unset;">
                                    <i class="nexmoefont icon-i-catalog"></i>
                                    <div class="nexmoe-toc">
                                        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E6%B8%B8%E6%88%8F%E4%B8%8D%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">无游戏不编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Leetcode%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%8E%86"><span class="toc-number">2.</span> <span class="toc-text">Leetcode学习日历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80"><span class="toc-number">2.1.</span> <span class="toc-text">数据结构基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD%EF%BC%9A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.1.1.</span> <span class="toc-text">算法性能：时间复杂度与空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.1.</span> <span class="toc-text">二分查找问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E7%A7%BB%E9%99%A4%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.2.</span> <span class="toc-text">元素移除问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.3.</span> <span class="toc-text">有序数组的平方问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.4.</span> <span class="toc-text">长度最小的子数组问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.5.</span> <span class="toc-text">螺旋矩阵问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="toc-number">2.2.6.</span> <span class="toc-text">轮转数组&#x2F;旋转链表&#x2F;翻转字符串里的单词</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-%E5%88%97%E8%A1%A8-%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98-%E6%89%8B%E6%92%95%E6%8E%92%E5%BA%8F"><span class="toc-number">2.2.7.</span> <span class="toc-text">数组[列表]排序问题:手撕排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93"><span class="toc-number">2.2.8.</span> <span class="toc-text">数组部分总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">2.3.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%93%BE%E8%A1%A8%EF%BC%9F"><span class="toc-number">2.3.1.</span> <span class="toc-text">什么是链表？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-number">2.3.2.</span> <span class="toc-text">移除节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8"><span class="toc-number">2.3.3.</span> <span class="toc-text">设计链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">2.3.4.</span> <span class="toc-text">翻转链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%A4%E8%8A%82%E7%82%B9%E4%BA%A4%E6%8D%A2"><span class="toc-number">2.3.5.</span> <span class="toc-text">两两节点交换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0N%E8%8A%82%E7%82%B9%EF%BC%88%E4%B8%89%E6%AC%A1AC%EF%BC%89"><span class="toc-number">2.3.6.</span> <span class="toc-text">删除链表的倒数N节点（三次AC）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4"><span class="toc-number">2.3.7.</span> <span class="toc-text">链表相交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II"><span class="toc-number">2.3.8.</span> <span class="toc-text">环形链表II</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8-%EF%BC%88key-value-O1%E6%97%B6%E9%97%B4%E8%AE%BF%E9%97%AE%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">哈希表 （key:value&#x2F;O1时间访问）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-number">2.4.1.</span> <span class="toc-text">有效字母异位词</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="toc-number">2.4.2.</span> <span class="toc-text">两个数组的交集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E4%B9%90%E6%95%B0"><span class="toc-number">2.4.3.</span> <span class="toc-text">快乐数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">2.4.4.</span> <span class="toc-text">三数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%BD%8D%E6%95%B0%E7%9A%84%E5%92%8C%E4%B8%8E%E5%8A%A0"><span class="toc-number">2.4.5.</span> <span class="toc-text">多位数的和与加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8E%E9%87%91%E4%BF%A1%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.6.</span> <span class="toc-text">赎金信问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.5.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.5.1.</span> <span class="toc-text">反转字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="toc-number">2.5.2.</span> <span class="toc-text">替换空格</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.5.3.</span> <span class="toc-text">比较字符串的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="toc-number">2.5.4.</span> <span class="toc-text">翻转字符串中的单词</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6"><span class="toc-number">2.5.5.</span> <span class="toc-text">左旋转字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0sreStr"><span class="toc-number">2.5.6.</span> <span class="toc-text">实现sreStr()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.5.7.</span> <span class="toc-text">重复的子字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E9%87%8D%E5%A4%8D%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%EF%BC%88%E4%B8%89%E6%AC%A1AC%EF%BC%89"><span class="toc-number">2.5.8.</span> <span class="toc-text">无重复最长子串（三次AC）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">2.5.9.</span> <span class="toc-text">字符中的最长回文子串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%88%E3%80%81%E5%A0%86%E3%80%81%E9%98%9F%E5%88%97"><span class="toc-number">2.6.</span> <span class="toc-text">数据结构：栈、堆、队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.1.</span> <span class="toc-text">有效括号问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A2%B0%E7%A2%B0%E6%B6%88%EF%BC%9A%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E6%B8%B8%E6%88%8F"><span class="toc-number">2.6.2.</span> <span class="toc-text">碰碰消：删除字符串中所有的相邻重复游戏</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91-%E9%80%92%E5%BD%92"><span class="toc-number">2.7.</span> <span class="toc-text">二叉树&#x2F;递归</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%88%E9%81%8D%E5%8E%86%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0%E9%80%92%E5%BD%92%EF%BC%8C%E8%BF%AD%E4%BB%A3%E7%9A%84%E6%80%9D%E6%83%B3%EF%BC%89"><span class="toc-number">2.7.1.</span> <span class="toc-text">二叉树的遍历（遍历问题学习递归，迭代的思想）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">2.7.2.</span> <span class="toc-text">二叉树的属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-number">2.7.2.1.</span> <span class="toc-text">方法总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%9E%84%E9%80%A0"><span class="toc-number">2.7.3.</span> <span class="toc-text">二叉树的修改与构造</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-number">2.7.3.1.</span> <span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">2.7.4.</span> <span class="toc-text">求二叉搜索树的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98"><span class="toc-number">2.7.5.</span> <span class="toc-text">公共祖先问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%9E%84%E9%80%A0-1"><span class="toc-number">2.7.6.</span> <span class="toc-text">二叉树的修改与构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93"><span class="toc-number">2.7.7.</span> <span class="toc-text">解题思路总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">常见算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B4%AA%E5%BF%83"><span class="toc-number">3.1.1.</span> <span class="toc-text">什么是贪心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.2.</span> <span class="toc-text">分发饼干问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%EF%BC%9A%E7%8B%AC%E7%AB%8B%E5%81%9A%E5%87%BA%E6%9D%A5%E7%9A%84%E7%AC%AC%E4%B8%80%E9%81%93%E4%B8%AD%E7%AD%89%E9%A2%98"><span class="toc-number">3.1.3.</span> <span class="toc-text">摆动序列问题：独立做出来的第一道中等题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C"><span class="toc-number">3.1.4.</span> <span class="toc-text">最大子序列和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98-%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E6%94%B6%E7%9B%8A"><span class="toc-number">3.1.5.</span> <span class="toc-text">经典问题:股票买卖获得的最大收益</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">回溯算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.1.</span> <span class="toc-text">组合问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.2.</span> <span class="toc-text">分割回文串问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.3.</span> <span class="toc-text">子集问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">3.3.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDP%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89"><span class="toc-number">3.3.1.</span> <span class="toc-text">什么是DP（动态规划）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4%EF%BC%88%E5%8A%A8%E8%A7%84%E4%BA%94%E9%83%A8%E6%9B%B2%EF%BC%89"><span class="toc-number">3.3.2.</span> <span class="toc-text">解题步骤（动规五部曲）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DP%E5%A6%82%E4%BD%95debug"><span class="toc-number">3.3.3.</span> <span class="toc-text">DP如何debug</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.4.</span> <span class="toc-text">背包问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-number">3.3.5.</span> <span class="toc-text">打家劫舍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.6.</span> <span class="toc-text">股票问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.7.</span> <span class="toc-text">子序列问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95DFS"><span class="toc-number">3.4.</span> <span class="toc-text">深度优先搜索算法DFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95BFS"><span class="toc-number">3.5.</span> <span class="toc-text">广度优先搜索算法BFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%8C%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E5%88%B7%E9%A2%98%E5%A5%97%E8%B7%AF%E9%9B%86%E5%90%88"><span class="toc-number">3.6.</span> <span class="toc-text">刷题总结，代码随想录就是一个刷题套路集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5%E5%90%8E%E7%9A%84%E7%BA%AF%E5%88%B7%E9%A2%98%E9%83%A8%E5%88%86"><span class="toc-number">4.</span> <span class="toc-text">以后的纯刷题部分</span></a></li></ol>
                                    </div>
                                </button>
                            
                        
                        <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
                    </div>
                </div>
                </div>
            </div>
        </div>
    </div>
    <div id="aplayerContent">
        <meting-js
        style="position:absolute; z-index:99999" 
        type="playlist" 
        server="netease" 
        id="6976153408" 
        fixed="true"
        autoplay="true"
        order="random"
        loop="all"
        list-folded="false"
        preload="auto"
        list-max-height="500px"
        lrc-type="1">
        </meting-js> 
    </div>
    <script>
        // 对所有链接跳转事件绑定pjax容器container,只在容器中跳转
        $(document).pjax('a[target!=_blank]', '#pageContent', {fragment: '#pageContent', timeout:8000})
    </script>
     
    <div id="nexmoe-search-space">
        <div class="search-container">
            <div class="search-header">
                <div class="search-input-container">
                    <input class="search-input" type="text" placeholder="搜索" oninput="sinput();">
                </div>
                <a class="search-close" onclick="sclose();">×</a>
            </div>
            <div class="search-body"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

 

<script async src="/js/app.js?v=1705851347264"></script>



<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>



    





<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
<!--烟花爆炸-->
<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
<script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
<script type="text/javascript" src="/js/firework.js"></script>
<!--单击显示文字-->
<script type="text/javascript" src="/js/click_show_text.js"></script>
</html>


